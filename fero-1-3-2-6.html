<!--
DEƒûƒ∞≈ûƒ∞KLƒ∞K √ñZETƒ∞ (‚â§10 satƒ±r)
1) AI Analytics Panel eklendi: Z-skoru, varyans/sapma, HR(50/100), aktif strateji, durum rozeti.
2) √ñr√ºnt√º Tanƒ±ma: 4‚Äì6 uzunluklu kayma penceresi, alternasyon/√ßift-blok/karma ≈üablonlar ‚Üí sinyal.
3) ƒ∞statistik: Ayarlanabilir |Z| e≈üiƒüi, W_SIGNAL; kƒ±sa/uzun hit-rate ve seri uzunluƒüu kartlarƒ±.
4) ML (hafif): Markov (k=3 varsayƒ±lan, UI‚Äôdan deƒüi≈üir), online sayƒ±m + g√ºven skoru.
5) Meta-√ñƒürenme: 3 uzman (trend/mean/flip) paralel; 50/100 pencerede en iyiyi se√ß veya aƒüƒ±rlƒ±klƒ± karƒ±≈üƒ±m.
6) Dinamik bahis/b√ºt√ße: mevcut modlara ek Kelly-lite ayarƒ±; ‚ÄúPASS‚Äù √ºst √ºste e≈üiƒüi (anti-pass loop).
7) I/O: CSV dƒ±≈üa aktar, √∂rnek dizi sim√ºlasyonu; localStorage kalƒ±cƒ±lƒ±k; Reset.
8) Global API (window.SicBoAI): init, onResult, suggestBet, setBankroll, setStrategy, exportCSV, reset.
9) Harici k√ºt√ºphane yok; tek dosya; mevcut ID/class/handler korunmu≈ütur.
--><!DOCTYPE html><html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Tanrƒ±nƒ±n Eli ‚Ä¢ Fero ‚Äî Sic Bo (Small/Big) ‚Ä¢ √ñƒürenen √áekirdek v3 (Contextual Bandit, PASS, Paroli, Stops, Tie-Meta)</title>
<style>
:root{
  --bg:#071022; --card:#0c1830; --muted:#9fb0d9; --text:#e6f0ff;
  --accent:#7c5cff; --accent2:#22e3a2; --danger:#ff6b6b; --warn:#eab308; --ok:#10b981;
  --btn:linear-gradient(90deg,var(--accent),var(--accent2));
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{margin:0;background:var(--bg);color:var(--text);
  font-family:Inter,system-ui,Segoe UI,Roboto,Arial;line-height:1.35;overflow-x:hidden}
.header{padding:16px;text-align:center;background:linear-gradient(180deg,#081329,#06101f);font-weight:800;color:#22e3a2}
.container{max-width:980px;margin:16px auto;padding:12px}/* Kart */ .card{background:linear-gradient(180deg,rgba(12,24,48,.95),rgba(8,14,30,.95)); border:1px solid rgba(124,92,255,.14);border-radius:12px;padding:16px;margin-bottom:16px; box-shadow:0 12px 40px rgba(2,6,23,.45)} .h4{margin:0 0 12px;color:var(--muted);font-size:13px;font-weight:800;text-transform:uppercase;letter-spacing:.5px} .sub{color:var(--muted);font-size:12px}

/* √ñneri ba≈ülƒ±ƒüƒ± + anlƒ±k stake */ .reco{display:flex;align-items:center;gap:10px;flex-wrap:wrap} .reco-badge{padding:6px 10px;border-radius:999px;font-weight:900} .reco-wait{background:#334155;color:#cbd5e1} .reco-small{background:#0b7a5e;color:#a7f3d0} .reco-big{background:#5c1c1c;color:#fecaca} .reco-pass{background:#3b2d06;color:#fde68a} .reco-pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06);color:#e6f0ff;font-weight:900} .status-pill{padding:6px 10px;border-radius:999px;font-weight:900;border:1px solid rgba(255,255,255,.12)} .halted{background:rgba(234,179,8,.1);color:#fde68a;border-color:rgba(234,179,8,.35)} .invert{background:rgba(124,92,255,.12);color:#c7b8ff;border-color:rgba(124,92,255,.35)}

/* Kayƒ±t butonlarƒ± */ .grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px} @media(max-width:640px){ .grid3{grid-template-columns:1fr} } .btn{cursor:pointer;border:none;border-radius:10px;padding:12px 14px;font-weight:800;background:var(--btn); color:#051025;transition:transform .14s,opacity .14s;min-height:44px;font-size:15px} .btn:active{transform:scale(.99)} .btn:hover{transform:translateY(-1px);opacity:.96} .btn[disabled]{opacity:.55;cursor:not-allowed} .btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.15);color:var(--text)} .btn-win{background:#0b7a5e} .btn-loss{background:#7f1d1d} .btn-tie{background:#3b2d06} .btn-warn{background:#eab308;color:#0a0a0a} .row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}

/* Tƒ±k hissi ‚Äì g√∂rsel pulse */ @keyframes tapWin{0%{box-shadow:0 0 0 0 rgba(34,227,162,.65);transform:scale(.98)}70%{box-shadow:0 0 0 16px rgba(34,227,162,0);transform:scale(1.01)}100%{box-shadow:0 0 0 0 rgba(34,227,162,0);transform:scale(1)}} @keyframes tapLoss{0%{box-shadow:0 0 0 0 rgba(255,107,107,.65);transform:scale(.98)}70%{box-shadow:0 0 0 16px rgba(255,107,107,0);transform:scale(1.01)}100%{box-shadow:0 0 0 0 rgba(255,107,107,0);transform:scale(1)}} @keyframes tapTie{0%{box-shadow:0 0 0 0 rgba(234,179,8,.65);transform:scale(.98)}70%{box-shadow:0 0 0 16px rgba(234,179,8,0);transform:scale(1.01)}100%{box-shadow:0 0 0 0 rgba(234,179,8,0);transform:scale(1)}} .pulse-win{animation:tapWin .42s ease-out} .pulse-loss{animation:tapLoss .42s ease-out} .pulse-tie{animation:tapTie .42s ease-out} .kbd{background:#0a1327;border:1px solid rgba(255,255,255,.12);padding:6px 8px;border-radius:8px;color:#9fb0d9;font-size:12px}

/* KPI */ .kpi-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:10px;margin-top:12px} .kpi{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);padding:12px;border-radius:10px} .kpi .t{font-size:12px;color:var(--muted)} .kpi .v{margin-top:6px;font-weight:900}

/* Tablo */ .table-wrap{overflow:auto;max-height:60vh;margin-top:12px;border-radius:10px} table{width:100%;border-collapse:collapse;font-size:13px;table-layout:fixed} th,td{padding:10px;border-bottom:1px solid rgba(255,255,255,.06);text-align:center;overflow:hidden;text-overflow:ellipsis;white-space:nowrap} th{position:sticky;top:0;background:rgba(7,16,34,.96);color:var(--muted)}

/* Ayarlar */ .settings.card{padding:12px} .form{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:8px} .group{display:flex;flex-direction:column;gap:6px} .label{color:var(--muted);font-size:11px} .input, select{ width:100%;background:transparent;border:1px solid rgba(255,255,255,.12); color:#fff;padding:8px 10px;border-radius:10px;min-height:36px;font-size:13px } .small-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px} .note{font-size:12px;color:var(--muted);margin-top:6px}

/* Warm-up panel & import */ .warm{margin-top:10px;padding:10px;border:1px dashed rgba(255,255,255,.18);border-radius:10px;background:rgba(255,255,255,.03)} .warm .title{font-weight:900;color:#a7b8e8;margin-bottom:6px} .warm .p{font-size:12px;color:#9fb0d9} .import{margin-top:10px;padding:10px;border:1px dashed rgba(124,92,255,.25);border-radius:10px;background:rgba(124,92,255,.06)} .import textarea{width:100%;min-height:120px;background:#0a1327;color:#e6f0ff;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:8px;font-family:ui-monospace,Consolas,monospace;font-size:12px}

/* SR only */ .sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}

/* <!-- AI-INJECT:styles --> / .ai-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(160px,1fr));gap:10px;margin-top:10px} .ai-kpi{background:rgba(255,255,255,.035);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:10px} .ai-kpi .t{font-size:11px;color:var(--muted)} .ai-kpi .v{margin-top:6px;font-weight:900} .ai-badge{padding:6px 10px;border-radius:999px;font-weight:900;display:inline-block} .ai-badge.neutral{background:#334155;color:#cbd5e1} .ai-badge.trend{background:#0b7a5e;color:#a7f3d0} .ai-badge.mean{background:#5c1c1c;color:#fecaca} .ai-badge.flip{background:#3b2d06;color:#fde68a} .ai-form{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:8px;margin-top:10px} .ai-form .group{display:flex;flex-direction:column;gap:6px} .ai-range{width:100%} .ai-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px} .badge-soft{background:rgba(124,92,255,.12);color:#c7b8ff;border:1px solid rgba(124,92,255,.25);border-radius:999px;padding:6px 10px;font-weight:800;display:inline-block} textarea.ai-seq{width:100%;min-height:88px;background:#0a1327;color:#e6f0ff;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:8px;font-family:ui-monospace,Consolas,monospace;font-size:12px} .small-note{font-size:11px;color:#9fb0d9} .switch{display:flex;align-items:center;gap:8px} .switch input{transform:scale(1.15)} / <!-- /AI-INJECT:styles --> */ </style>

</head>
<body>
<div class="header">üé≤ Tanrƒ±nƒ±n Eli ‚Ä¢ <b>Fero</b> ‚Äî Sic Bo (Small/Big) ‚Ä¢ √ñƒürenen √áekirdek v3 ‚Äî Contextual Bandit ‚Ä¢ PASS ‚Ä¢ Paroli ‚Ä¢ Stops ‚Ä¢ Tie-Meta</div><div class="container">  <!-- √ñneri + Eylem -->  <div class="card">
    <div class="h4">√ñneri</div>
    <div class="reco">
      <div id="recoBadge" class="reco-badge reco-wait">Dur</div>
      <div class="reco-pill">Sƒ±radaki Bahis: <span id="recoStake">‚Äî</span> TL</div>
      <div class="reco-pill">G√ºven: <span id="recoConf">‚Äî</span></div>
      <div id="haltPill" class="status-pill halted" style="display:none">EMNƒ∞YET: DURDURULDU</div>
      <div id="invPill" class="status-pill invert" style="display:none">Invert Mode</div>
      <div class="sub">Her el <b>Small</b>, <b>Big</b> ya da <b>Tie</b> tu≈üla. Sistem ‚ÄúDur / K√º√ß√ºk / B√ºy√ºk / PASS‚Äù ve tutarƒ± otomatik verir.</div>
    </div><!-- WARM-UP: Son 10 el -->
<div id="warmPanel" class="warm">
  <div class="title">Ba≈ülangƒ±√ß Kalibrasyonu</div>
  <div class="p">Ba≈ülamak i√ßin <b>son 10 eli</b> gir. Tamamlanƒ±nca √∂neri a√ßƒ±lƒ±r. (<span id="wStat">0/10</span>)</div>
  <div class="row">
    <button id="wSmall" class="btn btn-win">Small</button>
    <button id="wBig" class="btn btn-loss">Big</button>
    <button id="wTie" class="btn btn-tie">Tie</button>
    <button id="wUndo" class="btn ghost">Geri Al</button>
    <button id="wClear" class="btn ghost">Temizle</button>
  </div>
  <div class="kbd" style="margin-top:8px">Kƒ±sayol: 1=Small ¬∑ 2=Big ¬∑ 3=Tie ¬∑ Backspace=Geri</div>
</div>

<div class="grid3" style="margin-top:10px">
  <button id="btnSmall" class="btn btn-win">SMALL geldi</button>
  <button id="btnBig"   class="btn btn-loss">BIG geldi</button>
  <button id="btnTie"   class="btn btn-tie">TIE geldi (Kayƒ±p)</button>
</div>

<div class="row">
  <button id="btnUndo" class="btn ghost">Geri Al</button>
  <button id="btnClear" class="btn ghost">T√ºm Kayƒ±tlarƒ± Sil</button>
  <button id="btnResume" class="btn btn-warn" style="display:none">Emniyeti Kaldƒ±r (Devam)</button>
  <div class="kbd">Kƒ±sayol: S = Small ¬∑ B = Big ¬∑ T = Tie ¬∑ Z = Geri</div>
</div>

<div class="kpi-grid">
  <div class="kpi"><div class="t">√ñneri (Bu El)</div><div class="v" id="kRecoText">Dur</div></div>
  <div class="kpi"><div class="t">Bank</div><div class="v" id="kBank">5000.00</div></div>
  <div class="kpi"><div class="t">Stake (Sƒ±radaki)</div><div class="v" id="kStake">‚Äî</div></div>
  <div class="kpi"><div class="t">Dinamik Taban (u)</div><div class="v" id="kUnit">‚Äî</div></div>
  <div class="kpi"><div class="t">HWM (Tepe)</div><div class="v" id="kHWM">5000.00</div></div>
  <div class="kpi"><div class="t">Bahisli Eller (W/L)</div><div class="v" id="kWL">0 / 0</div></div>
  <div class="kpi"><div class="t">PNL (Seans)</div><div class="v" id="kPNL">+0.00</div></div>
  <div class="kpi"><div class="t">Kayƒ±p Serisi (Bahis)</div><div class="v" id="kLStreak">0</div></div>
  <div class="kpi"><div class="t">W WinRate (20)</div><div class="v" id="kWR">‚Äî</div></div>
  <div class="kpi"><div class="t">G√∂lge PnL (What-if)</div><div class="v" id="kShadow">+0.00</div></div>
  <div class="kpi"><div class="t">Strateji / Risk</div><div class="v" id="kSM">Adaptive / Normal</div></div>
</div>

<div class="h4" style="margin-top:12px">Ge√ßmi≈ü</div>
<div class="table-wrap">
  <table>
    <thead>
      <tr>
        <th>#</th><th>Kaynak</th><th>√ñneri</th><th>Ger√ßek</th><th>Bahis</th><th>Sonu√ß</th><th>Net</th><th>Bank</th>
      </tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>
</div>

<!-- Toplu import (opsiyonel) -->
<div class="import" id="importBox">
  <div class="h4">Toplu Ge√ßmi≈ü Yapƒ±≈ütƒ±r (Opsiyonel)</div>
  <div class="sub">Buraya tek tek satƒ±rlƒ± <b>small/big/tie</b> veya eski tablo satƒ±rlarƒ±nƒ± yapƒ±≈ütƒ±r. Sistem ‚ÄúGer√ßek‚Äù akƒ±≈üƒ±nƒ± ayƒ±klayƒ±p sim√ºle eder.</div>
  <textarea id="pasteArea" placeholder="small

big big tie ..."></textarea> <div class="row"> <button id="btnImport" class="btn">ƒ∞√ße Aktar ve Sim√ºle Et</button> <button id="btnImportClear" class="btn ghost">Alanƒ± Temizle</button> <button id="btnQuickOpt" class="btn ghost">Hƒ±zlƒ± Optimize (Z_THR)</button> </div> </div>

  </div>  <!-- AI-INJECT:panel -->  <div class="card" id="aiPanel">
    <div class="h4">Analytics Panel (AI)</div>
    <div class="ai-grid">
      <div class="ai-kpi"><div class="t">Durum</div><div class="v"><span id="aiStatus" class="ai-badge neutral">Sinyal yok</span></div></div>
      <div class="ai-kpi"><div class="t">Z-skoru / |Z| e≈üiƒüi</div><div class="v"><span id="aiZ">0.00</span> / <span id="aiZThrVal">1.10</span></div></div>
      <div class="ai-kpi"><div class="t">Std Sapma (W)</div><div class="v" id="aiStd">‚Äî</div></div>
      <div class="ai-kpi"><div class="t">Hit Rate (50)</div><div class="v" id="aiHR50">‚Äî</div></div>
      <div class="ai-kpi"><div class="t">Hit Rate (100)</div><div class="v" id="aiHR100">‚Äî</div></div>
      <div class="ai-kpi"><div class="t">Aktif Strateji</div><div class="v" id="aiActiveStrat">‚Äî</div></div>
      <div class="ai-kpi"><div class="t">Markov k</div><div class="v" id="aiKDisp">3</div></div>
      <div class="ai-kpi"><div class="t">ML G√ºven</div><div class="v" id="aiMLConf">‚Äî</div></div>
    </div><div class="ai-form" style="margin-top:12px">
  <div class="group">
    <label class="label">|Z| E≈üiƒüi</label>
    <input id="aiZThr" type="range" min="0.8" max="1.6" step="0.02" class="ai-range" value="1.10"/>
    <div class="small-note">Z k√º√ß√ºkse mean-revert zayƒ±flar; b√ºy√ºkse g√º√ßlenir.</div>
  </div>
  <div class="group">
    <label class="label">Sinyal Penceresi (W_SIGNAL)</label>
    <input id="aiWsig" type="number" class="input" value="12" min="8" max="30" step="1"/>
  </div>
  <div class="group">
    <label class="label">Markov k</label>
    <input id="aiKOrder" type="number" class="input" value="3" min="2" max="6" step="1"/>
  </div>
  <div class="group">
    <label class="label">Meta Se√ßim</label>
    <select id="aiMixMode" class="input">
      <option value="WINNER" selected>En ƒ∞yi Uzmanƒ± Kullan</option>
      <option value="WEIGHTED">Aƒüƒ±rlƒ±klƒ± Karƒ±≈üƒ±m</option>
    </select>
    <div class="small-note">Trend ‚Ä¢ Mean ‚Ä¢ Flip aƒüƒ±rlƒ±klarƒ± a≈üaƒüƒ±dan.</div>
  </div>
  <div class="group">
    <label class="label">Aƒüƒ±rlƒ±klar (Trend/Mean/Flip)</label>
    <div class="row" style="gap:6px">
      <input id="aiWTrend" class="input" type="number" value="1.0" step="0.1"/>
      <input id="aiWMean"  class="input" type="number" value="1.0" step="0.1"/>
      <input id="aiWFlip"  class="input" type="number" value="1.0" step="0.1"/>
    </div>
  </div>
  <div class="group">
    <label class="label">PASS Limit (√ºst √ºste)</label>
    <input id="aiPassMax" class="input" type="number" value="3" min="0" step="1"/>
    <div class="small-note">Anti-pass: limit a≈üƒ±ldƒ±ƒüƒ±nda taraf √∂ner.</div>
  </div>
  <div class="group">
    <label class="label">Para Y√∂netimi</label>
    <select id="aiMM" class="input">
      <option value="ADAPTIVE" selected>Adaptive (varsayƒ±lan)</option>
      <option value="DALEM">D'Alembert</option>
      <option value="PAROLI">Paroli</option>
      <option value="FIBO">Fibonacci</option>
    </select>
  </div>
  <div class="group">
    <label class="label">Kelly-lite (0‚Äì1)</label>
    <input id="aiKelly" class="input" type="number" min="0" max="1" step="0.05" value=""/>
    <div class="small-note">Bo≈ü bƒ±rak: risk modundan al.</div>
  </div>
  <div class="group switch">
    <input id="aiPersist" type="checkbox" checked/>
    <label class="label" for="aiPersist">Oturumu Kaydet (localStorage)</label>
  </div>
  <div class="group switch">
    <input id="aiAuto" type="checkbox"/>
    <label class="label" for="aiAuto">Auto-Bet (sadece √∂neri √ºretir)</label>
  </div>
</div>

<div style="margin-top:10px">
  <div class="label">Sim√ºlasyon/√ñrnek Dizi (S/B/T veya small/big/tie)</div>
  <textarea id="aiSeq" class="ai-seq" placeholder="s b s b b s ..."></textarea>
  <div class="ai-actions">
    <button id="btnAISim" class="btn">Sim√ºle Et</button>
    <button id="btnExportCSV" class="btn ghost">CSV Dƒ±≈üa Aktar</button>
    <button id="btnAIReset" class="btn ghost">AI Reset</button>
  </div>
</div>

  </div>
  <!-- /AI-INJECT:panel -->  <!-- AYARLAR -->  <div class="card settings">
    <div class="h4">Ayarlar</div>
    <div class="form">
      <div class="group">
        <label class="label" for="bankIn">Ba≈ülangƒ±√ß Bank</label>
        <input id="bankIn" class="input" type="number" value="5000" step="1" min="0"/>
      </div><div class="group">
    <label class="label">Bahis ƒ∞lerlemesi</label>
    <select id="strategyMode" class="input">
      <option value="ADAPTIVE" selected>Adaptive (varsayƒ±lan)</option>
      <option value="DALEM">D'Alembert</option>
      <option value="FIBO">Fibonacci</option>
      <option value="PAROLI">Paroli (pozitif)</option>
    </select>
    <div class="note">Adaptive: mevcut akƒ±llƒ± stake; D'Alembert/Fibonacci/Paroli opsiyonel.</div>
  </div>

  <div class="group">
    <label class="label">Risk Modu</label>
    <select id="riskMode" class="input">
      <option value="CONSERVATIVE">Konservatif</option>
      <option value="NORMAL" selected>Normal</option>
      <option value="AGGRESSIVE">Agresif</option>
    </select>
    <div class="note">u ve artƒ±≈ü katsayƒ±larƒ± buna g√∂re √∂l√ßeklenir; Kelly fraksiyonu deƒüi≈üir.</div>
  </div>

  <div class="group">
    <label class="label">PASS (Bahis Ge√ß) ‚Äî G√ºven E≈üiƒüi</label>
    <select id="passMode" class="input">
      <option value="OFF">Kapalƒ±</option>
      <option value="LOW">D√º≈ü√ºk</option>
      <option value="MEDIUM" selected>Orta</option>
      <option value="HIGH">Y√ºksek</option>
    </select>
    <div class="note">D√º≈ü√ºk g√ºven durumunda eli pas ge√ß. E≈üik=Trend~Mean ve |z| k√º√ß√ºkken.</div>
  </div>

  <div class="group">
    <label class="label">Stop-Loss / Stop-Win (%)</label>
    <div class="row" style="gap:6px">
      <input id="stopLossPct" class="input" type="number" value="10" step="1" min="0" style="max-width:120px"/>
      <input id="stopWinPct"  class="input" type="number" value="12" step="1" min="0" style="max-width:120px"/>
    </div>
    <div class="note">Baz: Ba≈ülangƒ±√ß Bank. A≈üƒ±lƒ±nca emniyetle durur, ‚ÄúDevam‚Äù ile kaldƒ±r.</div>
  </div>

  <div class="group">
    <label class="label">Paroli Maks Zincir</label>
    <input id="paroliMax" class="input" type="number" value="3" min="1" step="1"/>
    <div class="note">Paroli se√ßiliyken arka arkaya kazanƒ±mda ka√ß adƒ±m artƒ±rƒ±lacaƒüƒ±.</div>
  </div>

  <div class="group">
    <label class="label">Tie Meta (Stake indirimi %)</label>
    <input id="tieReduce" class="input" type="number" value="30" min="0" max="80" step="5"/>
    <div class="note">Son 30 elde TIE oranƒ± beklenenden y√ºksekse stake bu oranda kƒ±sƒ±lƒ±r ya da PASS.</div>
  </div>

  <div class="group">
    <label class="label">Invert Mode (Deneysel)</label>
    <select id="invertMode" class="input">
      <option value="OFF" selected>Kapalƒ±</option>
      <option value="ON">A√ßƒ±k</option>
    </select>
    <div class="note">G√∂lge PnL bariz √∂ndeyse y√∂n√º tersine √ßevirmeyi dener.</div>
  </div>

  <div class="group">
    <div class="small-actions">
      <button id="apply" class="btn">Uygula</button>
      <button id="reset" class="btn ghost">Varsayƒ±lana D√∂n</button>
    </div>
    <div class="note">‚ÄúBank‚Äù girersin; <b>u</b> otomatik se√ßilir (~%0.6, moda g√∂re √∂l√ßeklenir).</div>
  </div>
</div>

  </div>
</div><!-- SR-Only canlƒ± b√∂lge --><div id="live" class="sr-only" aria-live="polite"></div><script>
(()=> {
/* =================== Parametreler & Sabitler =================== */
const MIN_WARMUP = 10;
let   W_WINRATE  = 20;       // win-rate penceresi
let   W_SIGNAL   = 12;       // z-skor pencere
let   Z_THR      = 1.10;     // z-skor e≈üiƒüi (adaptif)
const STREAK_TREND = 2;      // 2xRule
let   SERIES_LOCK  = 4;      // seri kilit e≈üiƒüi
const HYST_OPP     = 2;      // kilidi bozmak i√ßin kar≈üƒ± sinyal sayƒ±sƒ±
const HYST_LOSS    = 2;      // kilitte net 2 kayƒ±p ‚Üí kilidi √ß√∂z
const FF_HOLD_UNTIL_PAIR = true;
const DECAY = 0.995;         // bandit & e≈üiƒüe √ß√ºr√ºme

/* Stake kontrol (baz) */
let MAX_STEP_U          = 2;
let MAX_STEP_MULT       = 1.35;
let MAX_STEP_MULT_LOCK  = 1.25;
const CYCLE_TP_U        = 3;
const ADAPT_SERIES_LEN  = 6;

/* Risk moda g√∂re √ßarpanlar */
const riskProfiles = {
  CONSERVATIVE:{ uPct:0.005, kellyFrac:0.35, stepMult:1.20, stepU:1.5 },
  NORMAL:{       uPct:0.006, kellyFrac:0.50, stepMult:1.35, stepU:2.0 },
  AGGRESSIVE:{   uPct:0.008, kellyFrac:0.75, stepMult:1.45, stepU:2.5 }
};

/* Durum */
let baseBank = 5000, unit = 30;
let bank = baseBank, hwm = baseBank;
let stake = unit, maxStake = unit;
let lossStreak = 0, winStreak = 0;
let nHands = 0, wCount=0, lCount=0;
let warmActive = true;
let halted = false;

let recSide = 'NONE';   // 'S'|'B'|'NONE'|'PASS'
let recSource = 'NONE'; // 'PAIR'|'LOCK'|'TREND'|'MEAN'|'FALLBACK'|'PAUSE'|'CONF-PASS'|'PATTERN'

/* Ge√ßmi≈ü */
const warmSeq = [];
const histAll = [];     // 'S'|'B'|'T'
const histSig = [];     // 'S'|'B' (T ‚Üí son y√∂n)
const histBetWR = [];   // 1/0 sadece bahisli eller

/* Histerezis */
let lockedSide = null;  // 'S'|'B'|null
let oppSinceLockSig = 0;
let lockLossCount   = 0;

/* Flip-flop tutucu */
let ffHold = false;

/* Bandit (TREND vs MEAN) + decay */
const beta = { TREND:{a:1,b:1}, MEAN:{a:1,b:1} };
function decayBandit(){
  beta.TREND.a*=DECAY; beta.TREND.b*=DECAY;
  beta.MEAN.a *=DECAY; beta.MEAN.b *=DECAY;
  const target=1.10;
  Z_THR = Math.max(0.95, Math.min(1.25, Z_THR*DECAY + target*(1-DECAY)));
}

/* Kullanƒ±cƒ± ayarlarƒ± (UI) */
let strategyMode = 'ADAPTIVE';
let riskMode     = 'NORMAL';
let passMode     = 'MEDIUM'; // OFF | LOW | MEDIUM | HIGH
let stopLossPct  = 10;
let stopWinPct   = 12;
let paroliMax    = 3;
let tieReducePct = 30;
let invertMode   = 'OFF';

/* What-if toplam */
let shadowPNL = 0;

/* =================== Yardƒ±mcƒ±lar =================== */
const $ = id => document.getElementById(id);
const money = x => (Number.isFinite(x)?x:0).toFixed(2);

function setRecoBadge(side, tag=''){
  const el = $('recoBadge'); const t = $('kRecoText');
  el.className = 'reco-badge ';
  if(side==='S'){ el.classList.add('reco-small'); el.textContent='K√º√ß√ºƒüe Oyna'+(tag?` (${tag})`:``); t.textContent='K√º√ß√ºƒüe Oyna'; }
  else if(side==='B'){ el.classList.add('reco-big'); el.textContent='B√ºy√ºƒüe Oyna'+(tag?` (${tag})`:``); t.textContent='B√ºy√ºƒüe Oyna'; }
  else if(side==='PASS'){ el.classList.add('reco-pass'); el.textContent='PASS'+(tag?` (${tag})`:``); t.textContent='PASS'; }
  else{ el.classList.add('reco-wait'); el.textContent='Dur'+(tag?` (${tag})`:``); t.textContent='Dur'; }
}

function rollingWR(){ if(histBetWR.length===0) return null; return histBetWR.reduce((a,b)=>a+b,0)/histBetWR.length; }

function autoUnitFromBank(b){
  // risk moduna g√∂re taban u
  const profile = riskProfiles[riskMode]||riskProfiles.NORMAL;
  const basePct = profile.uPct;
  let u = Math.max(10, Math.round(b*basePct));
  const wr = rollingWR();
  if(wr!==null){
    if(wr>=0.58) u = Math.round(u*1.15);
    else if(wr<=0.46) u = Math.max(10, Math.round(u*0.9));
  }
  return u;
}
function dynamicUnit(){
  const wr = rollingWR(); let f = 1.0;
  if(wr!==null){
    if(wr >= 0.58) f = 1.10;
    else if(wr >= 0.52) f = 1.04;
    else if(wr <= 0.46) f = 0.90;
    else if(wr <= 0.48) f = 0.96;
  }
  return Math.max(1, Math.round(unit*f));
}
function lastStreak(side){ let c=0; for(let i=histSig.length-1;i>=0;i--){ if(histSig[i]===side) c++; else break; } return c; }
function flipFlop4(){ const a = histSig.slice(-4); return a.length===4 && (a[0]!==a[1] && a[0]===a[2] && a[1]===a[3]); }
function pairSeen(){ const a=histSig.slice(-2); return a.length===2 && a[0]===a[1]; }

function zScore(){
  const w = histSig.slice(-W_SIGNAL), n = w.length; if(n===0) return 0;
  const sCnt = w.filter(x=>x==='S').length; const mean = n*0.5; const sd = Math.sqrt(n*0.25); if(sd===0) return 0;
  return (sCnt-mean)/sd; // + Small a≈üƒ±rƒ±, - Big a≈üƒ±rƒ±
}

/* Desen sinyalleri (geni≈ületildi) */
function patternSignal(){
  const a = histSig;
  if(a.length>=6){
    const b = a.slice(-6).join('');
    if(b==='SSBBSS') return {side:'S', source:'PATTERN', tag:'2-2-2'};
    if(b==='BBSSBB') return {side:'B', source:'PATTERN', tag:'2-2-2'};
  }
  // Kayma penceresi 4‚Äì6: alternasyon/√ßift blok/karma
  const check = (len)=>{
    if(a.length<len) return null;
    const s = a.slice(-len).join('');
    // Alternasyon (SBSB / BSBS / ... len=4/5/6)
    if(/^(SB){2,3}$/.test(s) || /^(BS){2,3}$/.test(s)){
      // Kullanƒ±cƒ± isteƒüi: SBSB ‚Üí S √∂ner
      const side = s[0]==='S' ? 'S' : 'B';
      return {side, source:'PATTERN', tag:'ALT'};
    }
    // √áift blok: SSBB* veya BBSS*
    if(/^SSBB/.test(s)) return {side:'S', source:'PATTERN', tag:'SSBB'};
    if(/^BBSS/.test(s)) return {side:'B', source:'PATTERN', tag:'BBSS'};
    // Karma √∂rnekler: SBBS / BSSB ‚Üí ilk tarafa eƒüilim
    if(/SBBS$/.test(s)) return {side:'S', source:'PATTERN', tag:'SBBS'};
    if(/BSSB$/.test(s)) return {side:'B', source:'PATTERN', tag:'BSSB'};
    return null;
  };
  return check(6) || check(5) || check(4) || null;
}

/* Baƒülamsal aƒüƒ±rlƒ±klar (trend vs mean) */
function contextWeights(){
  const z = zScore();
  const sLen = lastStreak('S'), bLen = lastStreak('B');
  const series = Math.max(sLen,bLen);
  let wT = 1.0, wM = 1.0;

  if(series>=3) wT *= 1.08;
  if(series>=5) wT *= 1.10;
  if(Math.abs(z)>=Z_THR+0.2) wM *= 1.10;
  if(lossStreak>=3) wM *= 1.06;

  return {wT, wM};
}

/* G√ºven skoru ve PASS e≈üiƒüi */
function confidenceOfChoice(sT, sM){
  const d = Math.abs(sT - sM);
  const z = Math.min(2.5, Math.abs(zScore()))/2.5;
  return Math.max(0, Math.min(1, 0.4*d + 0.6*z));
}
function passThreshold(){
  if(passMode==='OFF') return -1;
  if(passMode==='LOW') return 0.20;
  if(passMode==='MEDIUM') return 0.35;
  return 0.50; // HIGH
}

/* Tie meta: son 30 elde TIE beklenenden (‚âà2.8%) belirgin fazlaysa */
function tieMetaEffect(){
  const W = 30, exp = 0.028;
  const hh = histAll.slice(-W);
  const ties = hh.filter(x=>x==='T').length;
  const ratio = hh.length? ties/hh.length : 0;
  return ratio > exp*2.2;
}

/* =================== √ñneri √ßekirdeƒüi =================== */
let lastConfShown = 0;
function recommendCore(){
  // Emniyet durak
  if(halted) return {side:'NONE', source:'PAUSE', tag:'EMNIYET', conf:0};

  // Flip-flop hold
  if(flipFlop4()){ ffHold = true; }
  if(ffHold){
    if(pairSeen()){ ffHold = false; } else { return {side:'NONE', source:'PAUSE', tag:'Flip-Flop', conf:0}; }
  }

  // Seri kilidi
  const sLen = lastStreak('S'), bLen = lastStreak('B');
  const lastSide = (sLen>0 && sLen>=bLen) ? 'S' : (bLen>0 ? 'B' : null);

  if(lockedSide===null){
    if(sLen >= SERIES_LOCK){ lockedSide='S'; oppSinceLockSig=0; lockLossCount=0; }
    else if(bLen >= SERIES_LOCK){ lockedSide='B'; oppSinceLockSig=0; lockLossCount=0; }
  }else{
    if(lastSide===lockedSide){ oppSinceLockSig=0; return {side:lockedSide, source:'LOCK', conf:.65}; }
    else if(lastSide!==null){
      oppSinceLockSig++;
      if(oppSinceLockSig < HYST_OPP) return {side:lockedSide, source:'LOCK', conf:.55};
      lockedSide=null; oppSinceLockSig=0; lockLossCount=0;
    }
  }
  if(lockedSide!==null) return {side:lockedSide, source:'LOCK', conf:.55};

  // PATTERN (√∂ncelik)
  const pat = patternSignal();
  if(pat) return { ...pat, conf:.60 };

  // === META: 3 uzman + Markov ===
  const meta = expertsDecision();
  if(meta && meta.side){ return meta; }

  // 2xRule
  if(sLen>=STREAK_TREND) return {side:'S', source:'PAIR', conf:.52};
  if(bLen>=STREAK_TREND) return {side:'B', source:'PAIR', conf:.52};

  // Z-skor adaylarƒ±
  const z = zScore();
  let meanCand=null;
  if(z >= Z_THR) meanCand = {side:'B', source:'MEAN', conf:.5};
  else if(z <= -Z_THR) meanCand = {side:'S', source:'MEAN', conf:.5};

  // mini trend adayƒ±
  let trendCand=null;
  if(sLen >= 1) trendCand = {side:'S', source:'TREND', conf:.5};
  if(bLen >= 1) trendCand = {side:'B', source:'TREND', conf:.5};

  // Bandit se√ßimi (baƒülamsal aƒüƒ±rlƒ±klƒ± Thompson)
  if(trendCand && meanCand){
    const draw = (a,b)=> Math.max(0, Math.min(1, a/(a+b) + (Math.random()*0.08-0.04)));
    let sT = draw(beta.TREND.a, beta.TREND.b);
    let sM = draw(beta.MEAN.a,  beta.MEAN.b);
    const {wT,wM} = contextWeights();
    sT *= wT; sM *= wM;

    // G√ºven & PASS
    const conf = confidenceOfChoice(sT,sM);
    const pThr = passThreshold();
    let choice = (sT>=sM) ? trendCand : meanCand;
    const tieHeavy = tieMetaEffect();
    if(tieHeavy && passMode!=='OFF'){ return {side:'PASS', source:'CONF-PASS', conf, tag:'Tie-Meta'}; }
    if(conf < pThr && passMode!=='OFF'){ return {side:'PASS', source:'CONF-PASS', conf, tag:'Low-Conf'}; }

    choice.conf = conf;
    return choice;
  }
  if(trendCand){ return trendCand; }
  if(meanCand){ return meanCand; }

  // Belirsiz ‚Üí son akƒ±≈üa katƒ±l
  if(histSig.length>=1){
    return {side:(histSig[histSig.length-1]==='S'?'S':'B'), source:'FALLBACK', conf:0.3};
  }
  return {side:'NONE', source:'NONE', conf:0};
}

function computeNextRecommendation(){
  if(warmActive){ recSide='NONE'; recSource='NONE'; $('recoConf').textContent='‚Äî'; updateAnalytics(); return; }
  const rec = recommendCore();
  recSide   = rec.side;
  recSource = rec.source;
  let conf = (typeof rec.conf==='number') ? rec.conf : 0.5;

  // PASS limit kontrol√º (anti pass-loop)
  if(recSide==='PASS'){
    ai.passConsec++;
    const limit = ai.passMax;
    if(limit>=0 && ai.passConsec>=limit){
      // En iyi uzmanƒ± zorla
      const force = expertsDecision(true);
      if(force && force.side){ recSide=force.side; recSource=force.source+'-FORCE'; conf=Math.max(conf, .45); }
      ai.passConsec = 0;
    }
  } else {
    ai.passConsec = 0;
  }

  // invert mode
  if(invertMode==='ON' && (recSide==='S' || recSide==='B')){
    recSide = (recSide==='S') ? 'B' : 'S';
    recSource = recSource + '-INV';
  }
  lastConfShown = conf;
  $('recoConf').textContent = (recSide==='NONE')?'‚Äî':(Math.round(conf*100)+'%');
  updateAnalytics();
}

/* =================== Stake ilerleme (√ßok modlu) =================== */
let fiboA=1, fiboB=1; // Fibonacci i√ßin
let paroliStreak=0;

function boundedSoft(prev, inc){
  const u = dynamicUnit();
  const capU = prev + MAX_STEP_U*u;
  const capP = Math.round(prev * (lockedSide ? MAX_STEP_MULT_LOCK : MAX_STEP_MULT));
  return Math.min(prev + inc, capU, capP);
}
function currentDD(){ return Math.max(0, hwm - bank); }

function kellyAdj(){
  const wr = rollingWR();
  const profile = riskProfiles[riskMode]||riskProfiles.NORMAL;
  // Kelly-lite override
  const kOverride = ai.kellyOverride;
  const frac = (typeof kOverride==='number' && kOverride>=0 && kOverride<=1) ? kOverride : profile.kellyFrac;
  if(wr===null || wr<=0.5) return 0;
  return Math.min(0.35, (2*wr - 1) * frac);
}

/* ADAPTIVE (mevcut) */
function dynamicK(dd, u){
  if(dd <= 5*u) return 2;
  if(dd <= 15*u) return 3;
  return 4;
}
function nextAfterLoss_ADAPT(prev){
  const u = dynamicUnit();
  const dd = currentDD();
  const K  = dynamicK(dd, u);
  const target = Math.max(u, Math.ceil(dd / Math.max(1,K)));
  const incNeed = Math.max(0, target - prev);
  const profile = riskProfiles[riskMode]||riskProfiles.NORMAL;
  MAX_STEP_MULT = profile.stepMult;
  MAX_STEP_U    = profile.stepU;

  const baseK = [1.00,1.15,1.25,1.35][Math.min(3, lossStreak)];
  const last = histSig[histSig.length-1] || 'S';
  const seriesLen = lastStreak(last);
  const seriesMult = (seriesLen >= ADAPT_SERIES_LEN) ? 0.6 : 1.0;
  let inc = Math.max(Math.ceil(baseK*u*seriesMult), incNeed, u);
  let ns  = boundedSoft(prev, inc);
  const kAdj = kellyAdj();
  ns = Math.round(ns * (1 + kAdj));
  if(lockedSide){
    const lockedAgainst = (lockedSide!==last);
    if(lockedAgainst){ ns = Math.max(u, Math.round(ns * 0.85)); }
  }
  return Math.max(u, ns);
}
function nextAfterWin_ADAPT(prev){
  const u = dynamicUnit();
  if(bank < hwm) return Math.max(u, Math.round(prev));
  let ns = Math.max(u, prev - 2*u);
  return ns;
}

/* D'Alembert */
function nextAfterLoss_DALEM(prev){
  const u = dynamicUnit();
  return Math.max(u, prev + u);
}
function nextAfterWin_DALEM(prev){
  const u = dynamicUnit();
  return Math.max(u, prev - u);
}

/* Fibonacci */
function nextAfterLoss_FIBO(prev){
  const u = dynamicUnit();
  const next = fiboA + fiboB; fiboA = fiboB; fiboB = next;
  return Math.max(u, next*u);
}
function onWin_FIBO(){
  const u = dynamicUnit();
  fiboA = 1; fiboB = 1;
  return Math.max(u, u);
}

/* Paroli (pozitif progression) */
function nextAfterWin_PAROLI(prev){
  const u = dynamicUnit();
  paroliStreak = Math.min(paroliMax, paroliStreak+1);
  const mults = [1.2,1.3,1.4,1.5];
  const k = Math.min(mults.length-1, paroliStreak-1);
  return Math.max(u, Math.round(prev * mults[k]));
}
function onLoss_PAROLI(){
  paroliStreak = 0;
  return dynamicUnit();
}

/* Ortak y√∂nlendirici */
function nextAfterLoss(prev){
  if(strategyMode==='DALEM') return nextAfterLoss_DALEM(prev);
  if(strategyMode==='FIBO')  return nextAfterLoss_FIBO(prev);
  return nextAfterLoss_ADAPT(prev);
}
function nextAfterWin(prev){
  if(strategyMode==='DALEM') return nextAfterWin_DALEM(prev);
  if(strategyMode==='PAROLI') return nextAfterWin_PAROLI(prev);
  if(strategyMode==='FIBO')   return onWin_FIBO();
  return nextAfterWin_ADAPT(prev);
}

/* =================== Emniyet: Stop-Loss / Stop-Win =================== */
function checkSafetyHalt(){
  const pnl = bank - baseBank;
  const sl = (stopLossPct/100)*baseBank;
  const sw = (stopWinPct/100)*baseBank;
  if(pnl <= -Math.abs(sl) || pnl >= Math.abs(sw)){
    halted = true;
    $('haltPill').style.display='inline-flex';
    $('btnResume').style.display='inline-flex';
  }
}

/* =================== Parametre adaptasyonu =================== */
function adaptParams(){
  const W=60;
  const recent = histBetWR.slice(-W);
  if(recent.length>=20){
    const wr = recent.reduce((a,b)=>a+b,0)/recent.length;
    if(wr<=0.45){ Z_THR = Math.max(0.95, Z_THR-0.02); W_SIGNAL = Math.max(10, W_SIGNAL-1); SERIES_LOCK = Math.max(3, SERIES_LOCK-1); }
    else if(wr>=0.57){ Z_THR = Math.min(1.25, Z_THR+0.02); W_SIGNAL = Math.min(16, W_SIGNAL+1); SERIES_LOCK = Math.min(6, SERIES_LOCK+1); }
  }
}

/* =================== UI =================== */
function refreshKPI(){
  $('kBank').textContent = money(bank);
  $('kStake').textContent = (recSide==='NONE'||recSide==='PASS')?'‚Äî':String(stake);
  $('kUnit').textContent  = String(dynamicUnit());
  $('kHWM').textContent   = money(hwm);
  $('kWL').textContent    = `${wCount} / ${lCount}`;
  $('kPNL').textContent   = (bank-baseBank>=0?'+':'-')+money(Math.abs(bank-baseBank));
  $('kLStreak').textContent = String(lossStreak);
  const wr = rollingWR(); $('kWR').textContent = wr===null?'‚Äî':(Math.round(wr*100)+'%');
  $('kShadow').textContent = (shadowPNL>=0?'+':'-')+money(Math.abs(shadowPNL));
  const tag = (recSource==='PAUSE'?'Flip-Flop/Emniyet': (recSource==='PAIR'?'2xRule': (recSource==='LOCK'?'Kilit': (recSource==='CONF-PASS'?'PASS': (recSource==='PATTERN'?'Pattern':recSource)))));
  setRecoBadge(recSide, (recSide==='NONE'||!tag)?'':tag);
  $('recoStake').textContent = (recSide==='NONE'||recSide==='PASS')?'‚Äî':String(stake);
  $('kSM').textContent = `${strategyMode==='ADAPTIVE'?'Adaptive':strategyMode} / ${riskMode[0]+riskMode.slice(1).toLowerCase()}`;
  $('invPill').style.display = (invertMode==='ON')?'inline-flex':'none';
}

/* Tablo satƒ±rƒ± + log */
let nHandsDisp=0;
const logRows = [];
function addRow(src, recUsed, actual, usedStake, outcomeStr, pnl, shadowThis){
  nHands++; nHandsDisp++;
  const tr = document.createElement('tr');
  const recTxt = recUsed==='NONE'?'‚Äî':(recUsed==='S'?'Small':(recUsed==='B'?'Big':'PASS'));
  const actTxt = actual==='S'?'Small':(actual==='B'?'Big':'Tie');
  tr.innerHTML = `
    <td>${nHandsDisp}</td>
    <td>${src}</td>
    <td>${recTxt}</td>
    <td>${actTxt}</td>
    <td>${(recUsed==='NONE'||recUsed==='PASS')?'‚Äî':usedStake}</td>
    <td>${outcomeStr}
      ${(recUsed!=='NONE' && recUsed!=='PASS')?`<div class="sub" style="opacity:.8">G√∂lge: ${(shadowThis>=0?'+':'-')+money(Math.abs(shadowThis))} ‚Ä¢ Toplam: ${(shadowPNL>=0?'+':'-')+money(Math.abs(shadowPNL))}</div>`:''}
    </td>
    <td>${(recUsed==='NONE'||recUsed==='PASS')?'‚Äî':(pnl>=0?'+':'-')+money(Math.abs(pnl))}</td>
    <td>${money(bank)}</td>
  `;
  const tb = $('tbody'); if(tb.firstChild) tb.insertBefore(tr, tb.firstChild); else tb.appendChild(tr);
  $('live').textContent = `El ${nHandsDisp}: ${actTxt} geldi, ${outcomeStr}.`;
  // log
  logRows.push({i:nHandsDisp, src, rec:recTxt, actual:actTxt, stake:(recUsed==='NONE'||recUsed==='PASS')?0:usedStake, outcome:outcomeStr, pnl: (recUsed==='NONE'||recUsed==='PASS')?0:pnl, bank:bank, conf: Math.round(lastConfShown*100)});
}

/* =================== Sonu√ß i≈ülence =================== */
function onOutcome(tag){ // 'S'|'B'|'T'
  if(warmActive){ warmAdd(tag); return; }

  // decay & adapt
  decayBandit();      
  adaptParams();

  // Emniyet aktifse √∂neri NONE kalsƒ±n, sadece kayƒ±t
  const recUsed = (halted ? 'NONE' : recSide);
  const srcUsed = recSource;
  let usedStake = (recUsed==='NONE'||recUsed==='PASS') ? 0 : stake;

  // Tie meta: stake azalt
  if(usedStake>0 && tieMetaEffect() && passMode==='OFF'){
    usedStake = Math.max(1, Math.round(usedStake*(1 - tieReducePct/100)));
  }

  // Markov g√ºncellemesi i√ßin √∂nceki k anahtarƒ±
  const prevSeqForMarkov = histSig.slice(-ai.kOrder).join('');

  histAll.push(tag);
  if(tag==='T'){ const last = histSig[histSig.length-1]; if(last) histSig.push(last); }
  else { histSig.push(tag); }
  if(histSig.length>6000) histSig.shift();

  // ML: Markov sayƒ±m g√ºncelle
  if(prevSeqForMarkov.length===ai.kOrder){
    const key = prevSeqForMarkov;
    const m = ai.markov;
    if(!m[key]) m[key] = {S:0,B:0};
    if(tag==='S') m[key].S++; else if(tag==='B') m[key].B++;
  }

  // Meta: son uzman tahminlerini deƒüerlendir
  evaluateExperts(tag);

  let pnl=0, out='Bekle', shadowThis=0;

  if(recUsed!=='NONE' && recUsed!=='PASS'){
    const isWin = (tag!=='T' && recUsed===tag);
    if(isWin){
      pnl = +usedStake; bank += pnl; out='KAZAN'; wCount++; lossStreak=0; winStreak++;
      if(srcUsed.includes('TREND')) beta.TREND.a+=1; else if(srcUsed.includes('MEAN')) beta.MEAN.a+=1;
      if(srcUsed==='LOCK'){ SERIES_LOCK = Math.max(3, Math.round(SERIES_LOCK*0.98)); }
      stake = nextAfterWin(stake);
      histBetWR.push(1); if(histBetWR.length>W_WINRATE) histBetWR.shift();
      if(lockedSide){ lockLossCount = 0; }
    }else{
      pnl = -usedStake; bank += pnl; out='KAYIP'; lCount++; lossStreak++; winStreak=0;
      if(srcUsed.includes('TREND')) beta.TREND.b+=1; else if(srcUsed.includes('MEAN')) beta.MEAN.b+=1;
      if(lockedSide && recUsed===lockedSide){
        lockLossCount++;
        const z = zScore();
        const zOpp = (lockedSide==='S' && z<=-Z_THR) || (lockedSide==='B' && z>=Z_THR);
        if(zOpp || lockLossCount>=HYST_LOSS){ lockedSide=null; oppSinceLockSig=0; lockLossCount=0; }
        if(!lockedSide){ SERIES_LOCK = Math.min(6, Math.round(SERIES_LOCK*1.05)); }
      }
      if(strategyMode==='PAROLI'){ stake = onLoss_PAROLI(); }
      stake = nextAfterLoss(stake);
      histBetWR.push(0); if(histBetWR.length>W_WINRATE) histBetWR.shift();
    }

    // What-if (kar≈üƒ± y√∂n)
    const altSide = (recUsed==='S') ? 'B' : 'S';
    const altWin  = (tag!=='T' && altSide===tag);
    shadowThis = altWin ? +usedStake : -usedStake;
    shadowPNL += shadowThis;
  }else{
    // PASS veya NONE: banditleri hafif√ße √ß√ºr√ºt
    beta.TREND.a*=DECAY; beta.TREND.b*=DECAY;
    beta.MEAN.a *=DECAY; beta.MEAN.b *=DECAY;
    out = (recUsed==='PASS')?'PASS':'Bekle';
  }

  const prevHWM = hwm;
  if(bank>hwm) hwm = bank;
  if(hwm>prevHWM){ stake = dynamicUnit(); }
  if(bank>=hwm && (bank-baseBank) >= CYCLE_TP_U*dynamicUnit()){ stake = dynamicUnit(); }
  maxStake = Math.max(maxStake, stake);

  // Emniyet kontrol
  checkSafetyHalt();

  addRow(srcUsed, recUsed, tag, usedStake, out, pnl, shadowThis);

  // G√∂lge inversiyon uyarƒ±sƒ±
  const realPNL = bank - baseBank;
  if(shadowPNL - realPNL > 5*dynamicUnit() && histBetWR.length>=20){
    $('invPill').title = 'G√∂lge PnL √∂nde: invert mode deneyebilirsin (Ayarlar)';
  }

  // Persist
  if(ai.persist){ saveState(); }

  computeNextRecommendation();
  refreshKPI();
}

/* =================== Warm-up =================== */
function warmUpdateUI(){ $('wStat').textContent = `${warmSeq.length}/${MIN_WARMUP}`; }
function warmAdd(tag){
  if(!warmActive) return;
  if(warmSeq.length>=MIN_WARMUP) return;
  warmSeq.push(tag); warmUpdateUI();
  if(warmSeq.length===MIN_WARMUP){
    for(const t of warmSeq){
      histAll.push(t);
      if(t==='T'){ const last = histSig[histSig.length-1]; if(last) histSig.push(last); }
      else { histSig.push(t); }
    }
    warmSeq.length = 0; warmActive = false; $('warmPanel').style.display = 'none';
    // warm-up sonrasƒ±
    unit  = autoUnitFromBank(baseBank);
    stake = unit; fiboA=1;fiboB=1; paroliStreak=0;
    computeNextRecommendation();
    refreshKPI();
  }
}
function warmUndo(){ if(warmActive && warmSeq.length>0){ warmSeq.pop(); warmUpdateUI(); } }
function warmClear(){ if(warmActive){ warmSeq.length=0; warmUpdateUI(); } }

/* =================== Undo / Clear / Apply =================== */
function replay(){
  const sm = strategyMode, rm=riskMode, pm=passMode, sl=stopLossPct, sw=stopWinPct, par=paroliMax, tr=tieReducePct, inv=invertMode;
  bank = baseBank; hwm = baseBank;
  unit = autoUnitFromBank(baseBank); stake = unit; maxStake=unit;
  lossStreak=0; winStreak=0; nHands=0; nHandsDisp=0; wCount=0; lCount=0;
  histAll.length=0; histSig.length=0; histBetWR.length=0;
  lockedSide=null; oppSinceLockSig=0; lockLossCount=0; ffHold=false;
  recSide='NONE'; recSource='NONE'; shadowPNL=0; halted=false;
  beta.TREND={a:1,b:1}; beta.MEAN={a:1,b:1}; Z_THR = parseFloat($('aiZThr').value)||Z_THR; SERIES_LOCK = 4; W_SIGNAL=parseInt($('aiWsig').value)||12;
  $('tbody').innerHTML='';
  warmActive = true; warmSeq.length=0; $('warmPanel').style.display = 'block'; warmUpdateUI();
  $('haltPill').style.display='none'; $('btnResume').style.display='none';
  // restore settings
  strategyMode=sm; riskMode=rm; passMode=pm; stopLossPct=sl; stopWinPct=sw; paroliMax=par; tieReducePct=tr; invertMode=inv;
  // AI resetler
  aiReset(false);
  refreshKPI();
}
function undo(){
  if(warmActive){ warmUndo(); return; }
  if(!histAll.length) return;
  const copy = histAll.slice(0,-1);
  // reset ve yeniden y√ºr√ºt
  bank = baseBank; hwm = baseBank;
  unit = autoUnitFromBank(baseBank); stake=unit; maxStake=unit;
  lossStreak=0; winStreak=0; nHands=0; nHandsDisp=0; wCount=0; lCount=0;
  histAll.length=0; histSig.length=0; histBetWR.length=0;
  lockedSide=null; oppSinceLockSig=0; lockLossCount=0; ffHold=false;
  recSide='NONE'; recSource='NONE'; shadowPNL=0; halted=false;
  beta.TREND={a:1,b:1}; beta.MEAN={a:1,b:1}; Z_THR = parseFloat($('aiZThr').value)||1.10; SERIES_LOCK = 4; W_SIGNAL=parseInt($('aiWsig').value)||12;
  $('tbody').innerHTML='';
  warmActive=false; $('warmPanel').style.display='none';
  $('haltPill').style.display='none'; $('btnResume').style.display='none';
  aiReset(false);
  for(const t of copy){ computeNextRecommendation(); onOutcome(t); }
  computeNextRecommendation(); refreshKPI();
}
function clearAll(){ if(confirm('T√ºm kayƒ±tlarƒ± silmek istiyor musun?')){ replay(); } }
function apply(){
  const b = parseFloat($('bankIn').value);
  if(!Number.isFinite(b)||b<0){alert('Ge√ßerli bank gir.');return}
  baseBank=b;

  strategyMode = $('strategyMode').value;
  riskMode     = $('riskMode').value;
  passMode     = $('passMode').value;
  stopLossPct  = parseFloat($('stopLossPct').value)||0;
  stopWinPct   = parseFloat($('stopWinPct').value)||0;
  paroliMax    = Math.max(1, parseInt($('paroliMax').value)||3);
  tieReducePct = Math.max(0, Math.min(80, parseInt($('tieReduce').value)||0));
  invertMode   = $('invertMode').value;

  const profile = riskProfiles[riskMode]||riskProfiles.NORMAL;
  MAX_STEP_MULT = profile.stepMult;
  MAX_STEP_U    = profile.stepU;

  // Para y√∂netimi se√ßicisi ile senkron
  $('aiMM').value = strategyMode;

  replay(); // unit otomatik hesaplanƒ±r
}

/* =================== Import & Hƒ±zlƒ± Optimize =================== */
function parseLinesToTags(text){
  const tags = [];
  const lines = text.split(/\s+/);
  for(const raw of lines){
    const t = raw.trim().toLowerCase();
    if(!t) continue;
    if(/^s|small$/.test(t)) { tags.push('S'); continue; }
    if(/^b|big$/.test(t))   { tags.push('B'); continue; }
    if(/^t|tie$/.test(t))   { tags.push('T'); continue; }
  }
  return tags;
}
function seedLearningFromDataset(){
  beta.TREND.a = 3; beta.TREND.b = 2;
  beta.MEAN.a  = 2; beta.MEAN.b  = 3;
  Z_THR = parseFloat($('aiZThr').value)||1.10; SERIES_LOCK = 3;
}
function importAndSim(text){
  const tags = parseLinesToTags(text);
  if(tags.length===0){ alert('Uygun satƒ±r bulunamadƒ±.'); return; }

  seedLearningFromDataset();
  warmActive=false; $('warmPanel').style.display='none';
  unit = autoUnitFromBank(baseBank); stake=unit; fiboA=1;fiboB=1; paroliStreak=0;
  computeNextRecommendation(); refreshKPI();
  for(const t of tags){ onOutcome(t); }
  computeNextRecommendation(); refreshKPI();
}

/* Basit hƒ±zlƒ± optimizer: farklƒ± Z_THR adaylarƒ±nƒ± tarar */
function quickOptimize(){
  if(histAll.length<30){ alert('Optimize i√ßin en az 30 ger√ßek sonu√ß gerekli.'); return; }
  const dataset = histAll.slice();
  const candidates = [0.98,1.06,1.10,1.14,1.18,1.22];
  let best = {z:Z_THR, pnl:-1e9};

  for(const z of candidates){
    let tmpBank=baseBank, tmpHWM=baseBank;
    let tmpStake = autoUnitFromBank(baseBank);
    let tmpHistSig=[], tmpLoss=0;
    function tmpZ(){
      const w = tmpHistSig.slice(-W_SIGNAL), n=w.length; if(n===0) return 0;
      const s=w.filter(x=>x==='S').length; const mean=n*0.5; const sd=Math.sqrt(n*0.25); if(sd===0) return 0;
      return (s-mean)/sd;
    }
    for(const tag of dataset){
      let sCand=null;
      const sLen = (()=>{let c=0; for(let i=tmpHistSig.length-1;i>=0;i--){ if(tmpHistSig[i]==='S') c++; else break; } return c;})();
      const bLen = (()=>{let c=0; for(let i=tmpHistSig.length-1;i>=0;i--){ if(tmpHistSig[i]==='B') c++; else break; } return c;})();
      if(sLen>=2) sCand='S'; else if(bLen>=2) sCand='B';
      else{
        const zz=tmpZ();
        if(zz>=z) sCand='B'; else if(zz<=-z) sCand='S';
        else sCand = tmpHistSig[tmpHistSig.length-1]||'S';
      }
      if(tag!=='T' && sCand===tag){ tmpBank+=tmpStake; tmpLoss=0; tmpStake=Math.max(autoUnitFromBank(baseBank), tmpStake-2*autoUnitFromBank(baseBank)); }
      else if(sCand!=='NONE'){ tmpBank-=tmpStake; tmpLoss++; tmpStake=Math.max(autoUnitFromBank(baseBank), tmpStake + autoUnitFromBank(baseBank)); }
      if(tag==='T'){ const last=tmpHistSig[tmpHistSig.length-1]; if(last) tmpHistSig.push(last); } else tmpHistSig.push(tag);
      if(tmpBank>tmpHWM) tmpHWM=tmpBank;
    }
    const pnl = tmpBank - baseBank;
    if(pnl>best.pnl) best={z, pnl};
  }
  alert(`Hƒ±zlƒ± Optimize: En iyi Z_THR ‚âà ${best.z.toFixed(2)} ‚Ä¢ Tahmini PnL: ${best.pnl>0?'+':''}${best.pnl.toFixed(2)} TL`);
  Z_THR = best.z;
  $('aiZThr').value = best.z.toFixed(2);
  $('aiZThrVal').textContent = best.z.toFixed(2);
  computeNextRecommendation(); refreshKPI(); updateAnalytics();
}

/* =================== Baƒülantƒ±lar (mevcut) =================== */
function guardTap(btn, pulse, cb){
  if(btn._lock) return; btn._lock=true;
  btn.classList.remove(pulse); void btn.offsetWidth; btn.classList.add(pulse);
  try{ cb(); } finally { setTimeout(()=>{ btn._lock=false; }, 220); }
}
$('btnSmall').addEventListener('click',()=>guardTap($('btnSmall'),'pulse-win', ()=>onOutcome('S')));
$('btnBig').addEventListener('click',  ()=>guardTap($('btnBig'),'pulse-loss', ()=>onOutcome('B')));
$('btnTie').addEventListener('click',  ()=>guardTap($('btnTie'),'pulse-tie',  ()=>onOutcome('T')));
$('btnUndo').addEventListener('click', ()=>undo());
$('btnClear').addEventListener('click',()=>clearAll());
$('btnResume').addEventListener('click',()=>{ halted=false; $('haltPill').style.display='none'; $('btnResume').style.display='none'; computeNextRecommendation(); refreshKPI(); });
$('apply').addEventListener('click',  ()=>apply());
$('reset').addEventListener('click',  ()=>{ $('bankIn').value=5000;
  $('strategyMode').value='ADAPTIVE';
  $('riskMode').value='NORMAL';
  $('passMode').value='MEDIUM';
  $('stopLossPct').value=10; $('stopWinPct').value=12;
  $('paroliMax').value=3; $('tieReduce').value=30;
  $('invertMode').value='OFF';
  apply(); });

/* Warm-up */
$('wSmall').addEventListener('click', ()=>guardTap($('wSmall'),'pulse-win', ()=>warmAdd('S')));
$('wBig').addEventListener('click',   ()=>guardTap($('wBig'),'pulse-loss',()=>warmAdd('B')));
$('wTie').addEventListener('click',   ()=>guardTap($('wTie'),'pulse-tie', ()=>warmAdd('T')));
$('wUndo').addEventListener('click',  ()=>warmUndo());
$('wClear').addEventListener('click', ()=>warmClear());

/* Import & Optimize */
$('btnImport').addEventListener('click', ()=>importAndSim($('pasteArea').value));
$('btnImportClear').addEventListener('click', ()=>{$('pasteArea').value='';});
$('btnQuickOpt').addEventListener('click', ()=>quickOptimize());

/* Kƒ±sayollar */
document.addEventListener('keydown',(e)=>{
  const t = e.target.tagName.toLowerCase();
  if(t==='input'||t==='select'||t==='textarea') return;
  if(e.key==='s'||e.key==='S'){ e.preventDefault(); $('btnSmall').click(); }
  if(e.key==='b'||e.key==='B'){ e.preventDefault(); $('btnBig').click(); }
  if(e.key==='t'||e.key==='T'){ e.preventDefault(); $('btnTie').click(); }
  if(e.key==='z'||e.key==='Z'){ e.preventDefault(); $('btnUndo').click(); }
  if(e.key==='1'){ e.preventDefault(); $('wSmall').click(); }
  if(e.key==='2'){ e.preventDefault(); $('wBig').click(); }
  if(e.key==='3'){ e.preventDefault(); $('wTie').click(); }
  if(e.key==='Backspace'){ if(warmActive){ e.preventDefault(); $('wUndo').click(); } }
});

/* =================== AI-INJECT:scripts =================== */
/* ---- AI durum ve yardƒ±mcƒ±lar ---- */
const ai = {
  kOrder: 3,
  markov: Object.create(null),
  passMax: 3,
  passConsec: 0,
  persist: true,
  mixMode: 'WINNER',
  weights: {TREND:1, MEAN:1, FLIP:1},
  expertPerf: {
    TREND:[], MEAN:[], FLIP:[]
  },
  winWin: {short:50, long:100},
  lastExperts: null,
  kpi: {z:0,std:0,hr50:'‚Äî',hr100:'‚Äî',active:'‚Äî',mlConf:'‚Äî'},
  kellyOverride: null
};

function saveState(){
  const state = {
    baseBank, bank, hwm, stake, lossStreak, winStreak, nHands, wCount, lCount,
    histAll, histSig, histBetWR, beta, Z_THR, W_SIGNAL, SERIES_LOCK,
    strategyMode, riskMode, passMode, stopLossPct, stopWinPct, paroliMax, tieReducePct, invertMode,
    ai
  };
  try{ localStorage.setItem('sicbo_state_v3', JSON.stringify(state)); }catch(_){}
}
function loadState(){
  try{
    const s = JSON.parse(localStorage.getItem('sicbo_state_v3')||'null');
    if(!s) return;
    // Temel
    baseBank=s.baseBank; bank=s.bank; hwm=s.hwm; stake=s.stake;
    lossStreak=s.lossStreak; winStreak=s.winStreak; nHands=s.nHands; wCount=s.wCount; lCount=s.lCount;
    histAll.length=0; histSig.length=0; histBetWR.length=0;
    histAll.push(...s.histAll||[]); histSig.push(...s.histSig||[]); histBetWR.push(...s.histBetWR||[]);
    beta.TREND=s.beta?.TREND||{a:1,b:1}; beta.MEAN=s.beta?.MEAN||{a:1,b:1};
    Z_THR=s.Z_THR||Z_THR; W_SIGNAL=s.W_SIGNAL||W_SIGNAL; SERIES_LOCK=s.SERIES_LOCK||SERIES_LOCK;
    strategyMode=s.strategyMode||strategyMode; riskMode=s.riskMode||riskMode; passMode=s.passMode||passMode;
    stopLossPct=s.stopLossPct||stopLossPct; stopWinPct=s.stopWinPct||stopWinPct;
    paroliMax=s.paroliMax||paroliMax; tieReducePct=s.tieReducePct||tieReducePct; invertMode=s.invertMode||invertMode;
    // AI
    if(s.ai){
      ai.kOrder=s.ai.kOrder||3; ai.markov=s.ai.markov||Object.create(null);
      ai.passMax=s.ai.passMax||3; ai.mixMode=s.ai.mixMode||'WINNER'; ai.weights=s.ai.weights||{TREND:1,MEAN:1,FLIP:1};
      ai.expertPerf=s.ai.expertPerf||{TREND:[],MEAN:[],FLIP:[]};
      ai.persist=s.ai.persist!==false; ai.kellyOverride=s.ai.kellyOverride??null;
    }
    warmActive=false; $('warmPanel').style.display='none';
    // UI yansƒ±t
    $('bankIn').value = baseBank;
    $('strategyMode').value=strategyMode; $('riskMode').value=riskMode; $('passMode').value=passMode;
    $('stopLossPct').value=stopLossPct; $('stopWinPct').value=stopWinPct;
    $('paroliMax').value=paroliMax; $('tieReduce').value=tieReducePct; $('invertMode').value=invertMode;
    $('aiZThr').value=Z_THR.toFixed(2); $('aiZThrVal').textContent=Z_THR.toFixed(2);
    $('aiWsig').value=W_SIGNAL; $('aiKOrder').value=ai.kOrder; $('aiKDisp').textContent=ai.kOrder;
    $('aiMixMode').value=ai.mixMode; $('aiWTrend').value=ai.weights.TREND; $('aiWMean').value=ai.weights.MEAN; $('aiWFlip').value=ai.weights.FLIP;
    $('aiPassMax').value=ai.passMax; $('aiPersist').checked=ai.persist; $('aiMM').value=strategyMode;
  }catch(_){}
}

/* Z ve std hesap */
function getZStats(){
  const w = histSig.slice(-W_SIGNAL), n=w.length; if(n===0) return {z:0,std:0};
  const s=w.filter(x=>x==='S').length; const p=s/n; const sd = Math.sqrt(n*0.25);
  const z = sd===0?0:(s - n*0.5)/sd;
  const std = Math.sqrt(p*(1-p)); // Bernoulli std (p)
  return {z, std};
}

/* ---- ML: Markov ---- */
function markovPredict(){
  const k = ai.kOrder;
  if(histSig.length<k) return null;
  const key = histSig.slice(-k).join('');
  const counts = ai.markov[key] || {S:0, B:0};
  // Laplace d√ºzeltme
  const pS = (counts.S + 1) / (counts.S + counts.B + 2);
  const pB = 1 - pS;
  const side = pS>=pB ? 'S' : 'B';
  const conf = Math.abs(pS - 0.5) * 2; // 0..1
  return {side, conf, key, counts};
}

/* ---- Uzmanlar ---- */
function expertTrend(){
  const sLen = lastStreak('S'), bLen = lastStreak('B');
  if(sLen===0 && bLen===0) return null;
  return {side: (sLen>=bLen?'S':'B'), conf:0.5};
}
function expertMean(){
  const z = zScore();
  if(Math.abs(z)<Z_THR) return null;
  return {side: (z>0?'B':'S'), conf: Math.min(1, (Math.abs(z)-Z_THR)/ (1.6 - Z_THR + 1e-9) )};
}
function expertFlip(){
  if(histSig.length===0) return null;
  const last = histSig[histSig.length-1];
  return {side: (last==='S'?'B':'S'), conf:.45};
}

// Uzman performansƒ±nƒ± g√ºncelle (rolling 50/100)
function evaluateExperts(actualTag){
  const pred = ai.lastExperts;
  if(!pred) return;
  ['TREND','MEAN','FLIP'].forEach(k=>{
    const p = pred[k];
    if(!p) return;
    const hit = (actualTag!=='T' && p.side===actualTag) ? 1 : 0;
    ai.expertPerf[k].push(hit);
    if(ai.expertPerf[k].length>ai.winWin.long) ai.expertPerf[k].shift();
  });
}

// Uzmanlarƒ± √ßaƒüƒ±r ve meta-karar ver
function expertsDecision(forceWinner=false){
  const m = markovPredict();
  const t = expertTrend();
  const r = expertMean();
  const f = expertFlip();

  // Sonraki elde deƒüerlendirmek √ºzere sakla
  ai.lastExperts = {
    TREND: t, MEAN: r, FLIP: f
  };

  // Skorlar
  function hr(arr, n){
    if(!arr.length) return 0;
    const sub = arr.slice(-n);
    return sub.reduce((a,b)=>a+b,0)/sub.length;
    }
  const hrt = hr(ai.expertPerf.TREND, ai.winWin.short);
  const hrm = hr(ai.expertPerf.MEAN,  ai.winWin.short);
  const hrf = hr(ai.expertPerf.FLIP,  ai.winWin.short);
  const hrtL= hr(ai.expertPerf.TREND, ai.winWin.long);
  const hrmL= hr(ai.expertPerf.MEAN,  ai.winWin.long);
  const hrfL= hr(ai.expertPerf.FLIP,  ai.winWin.long);
  const score = {
    TREND: 0.6*hrt + 0.4*hrtL,
    MEAN:  0.6*hrm + 0.4*hrmL,
    FLIP:  0.6*hrf + 0.4*hrfL
  };

  ai.kpi.hr50 = Math.round((hrt*100))+' / '+Math.round((hrm*100))+' / '+Math.round((hrf*100))+' %';
  ai.kpi.hr100= Math.round((hrtL*100))+' / '+Math.round((hrmL*100))+' / '+Math.round((hrfL*100))+' %';

  // Aƒüƒ±rlƒ±klƒ± karƒ±≈üƒ±m
  let rec=null;
  if(ai.mixMode==='WEIGHTED' && (t||r||f)){
    let sScore = 0, bScore=0, totalW=0;
    if(t){ (t.side==='S'? sScore+=ai.weights.TREND*t.conf : bScore+=ai.weights.TREND*t.conf); totalW+=ai.weights.TREND*t.conf; }
    if(r){ (r.side==='S'? sScore+=ai.weights.MEAN *r.conf : bScore+=ai.weights.MEAN *r.conf); totalW+=ai.weights.MEAN *r.conf; }
    if(f){ (f.side==='S'? sScore+=ai.weights.FLIP *f.conf : bScore+=ai.weights.FLIP *f.conf); totalW+=ai.weights.FLIP *f.conf; }
    if(totalW>0){
      const side = (sScore>=bScore)?'S':'B';
      const conf = Math.min(1, Math.abs(sScore-bScore)/(totalW||1));
      rec = {side, source:'META-MIX', conf: Math.max(conf, 0.45)};
    }
  }

  // Winner-takes-all (varsayƒ±lan)
  if(!rec){
    const order = Object.entries(score).sort((a,b)=>b[1]-a[1]);
    const best = (order[0]&&order[0][0])||'TREND';
    let pick = null;
    if(best==='TREND') pick = t;
    if(best==='MEAN')  pick = r;
    if(best==='FLIP')  pick = f;
    if(!pick){ // fallback: mevcut uzmanlardan ilk uygun
      pick = t || r || f;
    }
    if(pick){
      rec = {side: pick.side, source: 'META:'+best, conf: Math.max(0.5, pick.conf||0.5)};
    }
  }

  // Markov sinyalini destekleyici olarak ele al
  if(m && rec){
    ai.kpi.mlConf = Math.round(m.conf*100)+'%';
    if(m.side===rec.side){ rec.conf = Math.min(1, rec.conf + m.conf*0.25); rec.source += '+MARKOV'; }
    else{
      // √áeli≈üki varsa g√ºveni hafif azalt
      rec.conf = Math.max(0.35, rec.conf - m.conf*0.15);
    }
  }else if(m && !rec){
    rec = {side: m.side, source:'MARKOV', conf: Math.max(0.45, m.conf)};
  }

  // forceWinner: her durumda bir taraf d√∂nd√ºr
  if(forceWinner && !rec){
    const last = histSig[histSig.length-1]||'S';
    rec = {side:last, source:'META:FALLBACK', conf:.4};
  }

  return rec;
}

/* ---- Analytics UI g√ºncelleme ---- */
function updateAnalytics(){
  const {z,std} = getZStats();
  ai.kpi.z = z; ai.kpi.std = std;
  $('aiZ').textContent = z.toFixed(2);
  $('aiStd').textContent = std?std.toFixed(3):'‚Äî';
  $('aiZThrVal').textContent = Z_THR.toFixed(2);
  $('aiKDisp').textContent = ai.kOrder;
  $('aiMLConf').textContent = ai.kpi.mlConf;

  // Status badge
  const el = $('aiStatus');
  el.className = 'ai-badge neutral';
  let text = 'Sinyal yok';
  if(recSource.startsWith('META')){ el.classList.add('trend'); text = recSource.replace('META:',''); }
  if(recSource.startsWith('META:MEAN')){ el.className='ai-badge mean'; text='Mean-revert'; }
  if(recSource.startsWith('META:FLIP')){ el.className='ai-badge flip'; text='Flip-flop'; }
  if(recSource==='TREND' || recSource.includes('TREND')){ el.className='ai-badge trend'; text='Trend'; }
  if(recSource==='MEAN'  || recSource.includes('MEAN')){ el.className='ai-badge mean'; text='Mean-revert'; }
  if(recSource==='PATTERN' || recSource.includes('PATTERN')){ el.className='ai-badge neutral'; text='Pattern'; }
  if(recSource==='CONF-PASS'){ el.className='ai-badge neutral'; text='PASS'; }
  if(Math.abs(z)>=Z_THR){ text += ' ‚Ä¢ Z y√ºksek'; }
  el.textContent = text;

  // HR kartlarƒ±
  const h = ai.kpi;
  $('aiHR50').textContent = h.hr50 || '‚Äî';
  $('aiHR100').textContent= h.hr100 || '‚Äî';

  // Aktif strateji
  $('aiActiveStrat').textContent = recSource || '‚Äî';

  // √ñneri/stake g√∂r√ºn√ºr
  refreshKPI();
}

/* ---- Panel event baƒülarƒ± ---- */
$('aiZThr').addEventListener('input', e=>{
  Z_THR = parseFloat(e.target.value)||Z_THR;
  $('aiZThrVal').textContent = Z_THR.toFixed(2);
  computeNextRecommendation(); updateAnalytics();
});
$('aiWsig').addEventListener('change', e=>{
  const v = Math.max(8, Math.min(30, parseInt(e.target.value)||W_SIGNAL));
  W_SIGNAL = v; e.target.value = v;
  computeNextRecommendation(); updateAnalytics();
});
$('aiKOrder').addEventListener('change', e=>{
  const v = Math.max(2, Math.min(6, parseInt(e.target.value)||ai.kOrder));
  ai.kOrder = v; $('aiKDisp').textContent=v;
  computeNextRecommendation(); updateAnalytics();
});
$('aiMixMode').addEventListener('change', e=>{ ai.mixMode = e.target.value; computeNextRecommendation(); });
$('aiWTrend').addEventListener('change', e=>{ ai.weights.TREND = parseFloat(e.target.value)||1; });
$('aiWMean').addEventListener('change', e=>{ ai.weights.MEAN  = parseFloat(e.target.value)||1; });
$('aiWFlip').addEventListener('change', e=>{ ai.weights.FLIP  = parseFloat(e.target.value)||1; });
$('aiPassMax').addEventListener('change', e=>{ ai.passMax = Math.max(0, parseInt(e.target.value)||3); });
$('aiPersist').addEventListener('change', e=>{ ai.persist = !!e.target.checked; if(ai.persist) saveState(); });
$('aiMM').addEventListener('change', e=>{ strategyMode = e.target.value; $('strategyMode').value=strategyMode; });
$('aiKelly').addEventListener('change', e=>{
  const v = e.target.value===''?null:Math.max(0, Math.min(1, parseFloat(e.target.value)));
  ai.kellyOverride = v;
});
$('btnAISim').addEventListener('click', ()=>{
  const seq = $('aiSeq').value.trim();
  if(!seq){ alert('Dizi gir.'); return; }
  importAndSim(seq);
});
$('btnExportCSV').addEventListener('click', ()=>{
  const csv = exportCSV();
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a=document.createElement('a');
  a.href=url; a.download='sicbo_log.csv'; a.click(); URL.revokeObjectURL(url);
});
$('btnAIReset').addEventListener('click', ()=>aiReset(true));

/* ---- CSV export ---- */
function exportCSV(){
  const headers = ['#','Kaynak','√ñneri','Ger√ßek','Bahis','Sonu√ß','Net','Bank','G√ºven%'];
  const rows = logRows.map(r=>[r.i,r.src,r.rec,r.actual,r.stake,r.outcome,r.pnl,r.bank,r.conf]);
  return [headers.join(','), ...rows.map(x=>x.join(','))].join('\n');
}

/* ---- AI reset ---- */
function aiReset(full=true){
  ai.markov = Object.create(null);
  ai.expertPerf = {TREND:[],MEAN:[],FLIP:[]};
  ai.lastExperts = null;
  ai.passConsec = 0;
  ai.kpi.mlConf = '‚Äî';
  if(full){
    logRows.length=0;
    $('tbody').innerHTML='';
    histAll.length=0; histSig.length=0; histBetWR.length=0;
    bank=baseBank; hwm=baseBank; stake=unit; lossStreak=0; winStreak=0; wCount=0; lCount=0;
    warmActive=true; $('warmPanel').style.display='block'; warmUpdateUI();
  }
  computeNextRecommendation(); updateAnalytics(); refreshKPI();
}

/* ---- Global API ---- */
window.SicBoAI = {
  init(opts={}){
    if(typeof opts.bankroll==='number') { baseBank=opts.bankroll; bank=baseBank; hwm=baseBank; $('bankIn').value=baseBank; }
    if(typeof opts.k==='number'){ ai.kOrder=opts.k; $('aiKOrder').value=ai.kOrder; $('aiKDisp').textContent=ai.kOrder; }
    if(typeof opts.zThr==='number'){ Z_THR=opts.zThr; $('aiZThr').value=Z_THR; $('aiZThrVal').textContent=Z_THR.toFixed(2); }
    if(opts.strategy){ strategyMode=opts.strategy; $('strategyMode').value=strategyMode; $('aiMM').value=strategyMode; }
    if(opts.persist===false){ ai.persist=false; $('aiPersist').checked=false; }
    computeNextRecommendation(); refreshKPI(); updateAnalytics();
    return true;
  },
  onResult(tag){ // 'S'|'B'|'T'
    onOutcome(tag);
    return true;
  },
  suggestBet(){
    computeNextRecommendation();
    const reason = recSource;
    const conf = Math.round(lastConfShown*100);
    const s = (recSide==='NONE'||recSide==='PASS')?0:stake;
    return {side:recSide, stake:s, reason, conf};
  },
  setBankroll(x){ baseBank=+x; bank=baseBank; hwm=baseBank; unit=autoUnitFromBank(baseBank); stake=unit; refreshKPI(); return true; },
  setStrategy(v){ strategyMode=v; $('strategyMode').value=v; $('aiMM').value=v; return true; },
  exportCSV(){ return exportCSV(); },
  reset(){ replay(); return true; }
};

/* Ba≈ülangƒ±√ß */
$('warmPanel').style.display = 'block';
$('haltPill').style.display='none';
warmUpdateUI();
setRecoBadge('NONE');
$('kStake').textContent='‚Äî';
$('kUnit').textContent=String(unit);
$('kBank').textContent=money(baseBank);

// Load persisted if any
loadState();
computeNextRecommendation();
refreshKPI();
updateAnalytics();
/* =================== /AI-INJECT:scripts =================== */
})();
</script></body>
</html>
