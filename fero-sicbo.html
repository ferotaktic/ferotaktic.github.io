<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"/>
<title>Tanrının Eli • Fero — Sic Bo (Small/Big) • Öğrenen Çekirdek v2 (Flip-Flop Hold, 2xRule, Bandit-Decay, Auto-Unit)</title>
<style>
:root{
  --bg:#071022; --card:#0c1830; --muted:#9fb0d9; --text:#e6f0ff;
  --accent:#7c5cff; --accent2:#22e3a2; --danger:#ff6b6b; --btn:linear-gradient(90deg,var(--accent),var(--accent2));
}
*{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
html,body{margin:0;background:var(--bg);color:var(--text);
  font-family:Inter,system-ui,Segoe UI,Roboto,Arial;line-height:1.35;overflow-x:hidden}
.header{padding:16px;text-align:center;background:linear-gradient(180deg,#081329,#06101f);font-weight:800;color:#22e3a2}
.container{max-width:980px;margin:16px auto;padding:12px}

/* Kart */
.card{background:linear-gradient(180deg,rgba(12,24,48,.95),rgba(8,14,30,.95));
  border:1px solid rgba(124,92,255,.14);border-radius:12px;padding:16px;margin-bottom:16px;
  box-shadow:0 12px 40px rgba(2,6,23,.45)}
.h4{margin:0 0 12px;color:var(--muted);font-size:13px;font-weight:800;text-transform:uppercase;letter-spacing:.5px}
.sub{color:var(--muted);font-size:12px}

/* Öneri başlığı + anlık stake */
.reco{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
.reco-badge{padding:6px 10px;border-radius:999px;font-weight:900}
.reco-wait{background:#334155;color:#cbd5e1}
.reco-small{background:#0b7a5e;color:#a7f3d0}
.reco-big{background:#5c1c1c;color:#fecaca}
.reco-pill{
  display:inline-flex;align-items:center;gap:6px;
  padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.12);
  background:rgba(255,255,255,.06);color:#e6f0ff;font-weight:900
}

/* Kayıt butonları */
.grid3{display:grid;grid-template-columns:repeat(3,1fr);gap:8px}
@media(max-width:640px){ .grid3{grid-template-columns:1fr} }
.btn{cursor:pointer;border:none;border-radius:10px;padding:12px 14px;font-weight:800;background:var(--btn);
  color:#051025;transition:transform .14s,opacity .14s;min-height:44px;font-size:15px}
.btn:active{transform:scale(.99)}
.btn:hover{transform:translateY(-1px);opacity:.96}
.btn[disabled]{opacity:.55;cursor:not-allowed}
.btn.ghost{background:transparent;border:1px solid rgba(255,255,255,.15);color:var(--text)}
.btn-win{background:#0b7a5e}
.btn-loss{background:#7f1d1d}
.btn-tie{background:#3b2d06}
.row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}

/* Tık hissi – görsel pulse */
@keyframes tapWin{0%{box-shadow:0 0 0 0 rgba(34,227,162,.65);transform:scale(.98)}
  70%{box-shadow:0 0 0 16px rgba(34,227,162,0);transform:scale(1.01)}
  100%{box-shadow:0 0 0 0 rgba(34,227,162,0);transform:scale(1)}}
@keyframes tapLoss{0%{box-shadow:0 0 0 0 rgba(255,107,107,.65);transform:scale(.98)}
  70%{box-shadow:0 0 0 16px rgba(255,107,107,0);transform:scale(1.01)}
  100%{box-shadow:0 0 0 0 rgba(255,107,107,0);transform:scale(1)}}
@keyframes tapTie{0%{box-shadow:0 0 0 0 rgba(234,179,8,.65);transform:scale(.98)}
  70%{box-shadow:0 0 0 16px rgba(234,179,8,0);transform:scale(1.01)}
  100%{box-shadow:0 0 0 0 rgba(234,179,8,0);transform:scale(1)}}
.pulse-win{animation:tapWin .42s ease-out}
.pulse-loss{animation:tapLoss .42s ease-out}
.pulse-tie{animation:tapTie .42s ease-out}
.kbd{background:#0a1327;border:1px solid rgba(255,255,255,.12);padding:6px 8px;border-radius:8px;color:#9fb0d9;font-size:12px}

/* KPI */
.kpi-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:10px;margin-top:12px}
.kpi{background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);padding:12px;border-radius:10px}
.kpi .t{font-size:12px;color:var(--muted)}
.kpi .v{margin-top:6px;font-weight:900}

/* Tablo */
.table-wrap{overflow:auto;max-height:60vh;margin-top:12px;border-radius:10px}
table{width:100%;border-collapse:collapse;font-size:13px;table-layout:fixed}
th,td{padding:10px;border-bottom:1px solid rgba(255,255,255,.06);text-align:center;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
th{position:sticky;top:0;background:rgba(7,16,34,.96);color:var(--muted)}

/* Ayarlar */
.settings.card{padding:12px}
.form{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:8px}
.group{display:flex;flex-direction:column;gap:6px}
.label{color:var(--muted);font-size:11px}
.input{
  width:100%;background:transparent;border:1px solid rgba(255,255,255,.12);
  color:#fff;padding:8px 10px;border-radius:10px;min-height:36px;font-size:13px
}
.small-actions{display:flex;gap:8px;flex-wrap:wrap;margin-top:6px}
.note{font-size:12px;color:var(--muted);margin-top:6px}

/* Warm-up panel */
.warm{margin-top:10px;padding:10px;border:1px dashed rgba(255,255,255,.18);border-radius:10px;background:rgba(255,255,255,.03)}
.warm .title{font-weight:900;color:#a7b8e8;margin-bottom:6px}
.warm .p{font-size:12px;color:#9fb0d9}

/* Toplu import */
.import{margin-top:10px;padding:10px;border:1px dashed rgba(124,92,255,.25);border-radius:10px;background:rgba(124,92,255,.06)}
.import textarea{width:100%;min-height:120px;background:#0a1327;color:#e6f0ff;border:1px solid rgba(255,255,255,.12);border-radius:8px;padding:8px;font-family:ui-monospace,Consolas,monospace;font-size:12px}

/* Erişilebilir canlı metin (gizli) */
.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);white-space:nowrap;border:0}
</style>
</head>
<body>
<div class="header">🎲 Tanrının Eli • <b>Fero</b> — Sic Bo (Small/Big) • Öğrenen Çekirdek v2 — Flip-Flop Hold • 2xRule • Bandit-Decay • Auto-Unit</div>

<div class="container">

  <!-- Öneri + Eylem -->
  <div class="card">
    <div class="h4">Öneri</div>
    <div class="reco">
      <div id="recoBadge" class="reco-badge reco-wait">Dur</div>
      <div class="reco-pill">Sıradaki Bahis: <span id="recoStake">—</span> TL</div>
      <div class="sub">Her el <b>Small</b>, <b>Big</b> ya da <b>Tie</b> tuşla. Sistem “Dur / Küçüğe Oyna / Büyüğe Oyna” ve tutarı otomatik verir.</div>
    </div>

    <!-- WARM-UP: Son 10 el -->
    <div id="warmPanel" class="warm">
      <div class="title">Başlangıç Kalibrasyonu</div>
      <div class="p">Başlamak için <b>son 10 eli</b> gir. Tamamlanınca öneri açılır. (<span id="wStat">0/10</span>)</div>
      <div class="row">
        <button id="wSmall" class="btn btn-win">Small</button>
        <button id="wBig" class="btn btn-loss">Big</button>
        <button id="wTie" class="btn btn-tie">Tie</button>
        <button id="wUndo" class="btn ghost">Geri Al</button>
        <button id="wClear" class="btn ghost">Temizle</button>
      </div>
      <div class="kbd" style="margin-top:8px">Kısayol: 1=Small · 2=Big · 3=Tie · Backspace=Geri</div>
    </div>

    <div class="grid3" style="margin-top:10px">
      <button id="btnSmall" class="btn btn-win">SMALL geldi</button>
      <button id="btnBig"   class="btn btn-loss">BIG geldi</button>
      <button id="btnTie"   class="btn btn-tie">TIE geldi (Kayıp)</button>
    </div>

    <div class="row">
      <button id="btnUndo" class="btn ghost">Geri Al</button>
      <button id="btnClear" class="btn ghost">Tüm Kayıtları Sil</button>
      <div class="kbd">Kısayol: S = Small · B = Big · T = Tie · Z = Geri</div>
    </div>

    <div class="kpi-grid">
      <div class="kpi"><div class="t">Öneri (Bu El)</div><div class="v" id="kRecoText">Dur</div></div>
      <div class="kpi"><div class="t">Bank</div><div class="v" id="kBank">5000.00</div></div>
      <div class="kpi"><div class="t">Stake (Sıradaki)</div><div class="v" id="kStake">—</div></div>
      <div class="kpi"><div class="t">Dinamik Taban (u)</div><div class="v" id="kUnit">—</div></div>
      <div class="kpi"><div class="t">HWM (Tepe)</div><div class="v" id="kHWM">5000.00</div></div>
      <div class="kpi"><div class="t">Bahisli Eller (W/L)</div><div class="v" id="kWL">0 / 0</div></div>
      <div class="kpi"><div class="t">PNL (Seans)</div><div class="v" id="kPNL">+0.00</div></div>
      <div class="kpi"><div class="t">Kayıp Serisi (Bahis)</div><div class="v" id="kLStreak">0</div></div>
      <div class="kpi"><div class="t">W WinRate (20)</div><div class="v" id="kWR">—</div></div>
      <div class="kpi"><div class="t">Gölge PnL (What-if)</div><div class="v" id="kShadow">+0.00</div></div>
    </div>

    <div class="h4" style="margin-top:12px">Geçmiş</div>
    <div class="table-wrap">
      <table>
        <thead>
          <tr>
            <th>#</th><th>Kaynak</th><th>Öneri</th><th>Gerçek</th><th>Bahis</th><th>Sonuç</th><th>Net</th><th>Bank</th>
          </tr>
        </thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>

    <!-- Toplu import (opsiyonel) -->
    <div class="import" id="importBox">
      <div class="h4">Toplu Geçmiş Yapıştır (Opsiyonel)</div>
      <div class="sub">Buraya tek tek satırlı <b>small/big/tie</b> veya eski tablo satırlarını yapıştır. Sistem “Gerçek” akışını ayıklayıp simüle eder.</div>
      <textarea id="pasteArea" placeholder="small
big
big
tie
..."></textarea>
      <div class="row">
        <button id="btnImport" class="btn">İçe Aktar ve Simüle Et</button>
        <button id="btnImportClear" class="btn ghost">Alanı Temizle</button>
      </div>
    </div>

  </div>

  <!-- AYARLAR (sade) -->
  <div class="card settings">
    <div class="h4">Ayarlar</div>
    <div class="form">
      <div class="group">
        <label class="label" for="bankIn">Başlangıç Bank</label>
        <input id="bankIn" class="input" type="number" value="5000" step="1" min="0"/>
      </div>
      <div class="group">
        <div class="small-actions">
          <button id="apply" class="btn">Uygula</button>
          <button id="reset" class="btn ghost">Varsayılana Dön</button>
        </div>
        <div class="note">Sadece “Bank” girersin; <b>başlangıç bahis (u)</b> otomatik seçilir (~%0.6). Yön ve risk yönetimi tamamen otomatik.</div>
      </div>
    </div>
  </div>
</div>

<!-- SR-Only canlı bölge -->
<div id="live" class="sr-only" aria-live="polite"></div>

<script>
(()=> {
/* =============== Parametreler =============== */
const MIN_WARMUP = 10;       // başta son 10 el gir
const W_WINRATE  = 20;       // win-rate penceresi
const W_SIGNAL   = 12;       // sinyal penceresi
let   Z_THR      = 1.10;     // Z-skor eşiği (adaptif, decay ile oynar)
const STREAK_TREND = 2;      // *** 2xRule: iki aynı → o tarafa oyna (öncelik)
let   SERIES_LOCK  = 4;      // dinamik kilit eşiği (öğrenimle ayarlanır)
const HYST_OPP     = 2;      // kilidi bozmak için ardışık karşı sinyal
const HYST_LOSS    = 2;      // kilitte 2 net kayıp → kilidi çöz
const FF_HOLD_UNTIL_PAIR = true; // flip-flopta iki aynı görülene kadar dur
const DECAY = 0.995;         // bandit & eşiklerde hafıza çürümesi

/* Stake kontrol */
const MAX_STEP_U          = 2;     // tek el max +2u
const MAX_STEP_MULT       = 1.35;  // tek el max +%35
const MAX_STEP_MULT_LOCK  = 1.25;  // kilitte tek el max +%25
const CYCLE_TP_U          = 3;     // HWM üstü küçük TP (+3u)
const ADAPT_SERIES_LEN    = 6;     // uzun seri → baskı azalt

/* =============== Durum =============== */
let baseBank = 5000, unit = 30;
let bank = baseBank, hwm = baseBank;
let stake = unit, maxStake = unit;
let lossStreak = 0;
let nHands = 0, wCount=0, lCount=0;

let recSide = 'NONE';   // 'S'|'B'|'NONE'
let recSource = 'NONE'; // 'PAIR'|'LOCK'|'TREND'|'MEAN'|'FALLBACK'|'PAUSE'|'NONE'
let warmActive = true;

const warmSeq = [];
const histAll = [];     // gerçek sonuç: 'S'|'B'|'T'
const histSig = [];     // sinyal akışı: 'S'|'B' (T nötr: son yön)
const histBetWR = [];   // bahisli 1/0

/* Histerezis */
let lockedSide = null;  // 'S'|'B'|null
let oppSinceLockSig = 0;
let lockLossCount   = 0;

/* Flip-flop tutucu */
let ffHold = false;

/* Bandit (TREND vs MEAN) + decay */
const beta = {
  TREND:{a:1,b:1},
  MEAN :{a:1,b:1}
};
function decayBandit(){
  beta.TREND.a*=DECAY; beta.TREND.b*=DECAY;
  beta.MEAN.a *=DECAY; beta.MEAN.b *=DECAY;
  // Z_THR küçük adımlarla ortalamaya çekilsin (1.10 ± 0.15 bandı)
  const target=1.10;
  Z_THR = Math.max(0.95, Math.min(1.25, Z_THR*DECAY + target*(1-DECAY)));
}
/* Yardımcılar */
const $ = id => document.getElementById(id);
const money = x => (Number.isFinite(x)?x:0).toFixed(2);
function setRecoBadge(side, tag=''){
  const el = $('recoBadge'); const t = $('kRecoText');
  el.className = 'reco-badge ';
  if(side==='S'){ el.classList.add('reco-small'); el.textContent='Küçüğe Oyna'+(tag?` (${tag})`:``); t.textContent='Küçüğe Oyna'; }
  else if(side==='B'){ el.classList.add('reco-big'); el.textContent='Büyüğe Oyna'+(tag?` (${tag})`:``); t.textContent='Büyüğe Oyna'; }
  else{ el.classList.add('reco-wait'); el.textContent='Dur'+(tag?` (${tag})`:``); t.textContent='Dur'; }
}
function rollingWR(){ if(histBetWR.length===0) return null; return histBetWR.reduce((a,b)=>a+b,0)/histBetWR.length; }
function autoUnitFromBank(b){
  // ~%0.6 bank; 3-9 bin arası 30-54 gibi değerler verir. alt sınır 10 TL
  const basePct = 0.006;
  let u = Math.max(10, Math.round(b*basePct));
  // WR iyiyse u artışını hafif genişlet (öğrenen)
  const wr = rollingWR();
  if(wr!==null){
    if(wr>=0.58) u = Math.round(u*1.15);
    else if(wr<=0.46) u = Math.max(10, Math.round(u*0.9));
  }
  return u;
}
function dynamicUnit(){
  // u; kısa vadeli WR ile mikro ayarlı (görsel KPI için)
  const wr = rollingWR(); let f = 1.0;
  if(wr!==null){
    if(wr >= 0.58) f = 1.10;
    else if(wr >= 0.52) f = 1.04;
    else if(wr <= 0.46) f = 0.90;
    else if(wr <= 0.48) f = 0.96;
  }
  return Math.max(1, Math.round(unit*f));
}
function lastStreak(side){ let c=0; for(let i=histSig.length-1;i>=0;i--){ if(histSig[i]===side) c++; else break; } return c; }
function flipFlop4(){
  const a = histSig.slice(-4);
  return a.length===4 && (a[0]!==a[1] && a[0]===a[2] && a[1]===a[3]);
}
function pairSeen(){ const a=histSig.slice(-2); return a.length===2 && a[0]===a[1]; }
function zScore(){
  const w = histSig.slice(-W_SIGNAL), n = w.length; if(n===0) return 0;
  const sCnt = w.filter(x=>x==='S').length; const mean = n*0.5; const sd = Math.sqrt(n*0.25); if(sd===0) return 0;
  return (sCnt-mean)/sd; // + Small aşırı, - Big aşırı
}

/* =============== Öneri çekirdeği =============== */
function recommendCore(){
  // Flip-flop hold: küçük-büyük-küçük-büyük görüldüyse dur ve iki aynı görülene kadar bekle
  if(flipFlop4()){ ffHold = true; }
  if(ffHold){
    if(pairSeen()){ ffHold = false; } else { return {side:'NONE', source:'PAUSE', tag:'Flip-Flop'}; }
  }

  // 0) SERİ KİLİDİ (histerezis)
  const sLen = lastStreak('S'), bLen = lastStreak('B');
  const lastSide = (sLen>0 && sLen>=bLen) ? 'S' : (bLen>0 ? 'B' : null);

  if(lockedSide===null){
    if(sLen >= SERIES_LOCK){ lockedSide='S'; oppSinceLockSig=0; lockLossCount=0; }
    else if(bLen >= SERIES_LOCK){ lockedSide='B'; oppSinceLockSig=0; lockLossCount=0; }
  }else{
    if(lastSide===lockedSide){ oppSinceLockSig=0; return {side:lockedSide, source:'LOCK'}; }
    else if(lastSide!==null){
      oppSinceLockSig++;
      if(oppSinceLockSig < HYST_OPP) return {side:lockedSide, source:'LOCK'};
      // eşiğe ulaştı → kilidi bırak
      lockedSide=null; oppSinceLockSig=0; lockLossCount=0;
    }
  }
  if(lockedSide!==null) return {side:lockedSide, source:'LOCK'};

  // 1) *** 2xRule (Öncelik): son iki aynıysa o tarafa ***
  if(sLen>=STREAK_TREND) return {side:'S', source:'PAIR'};
  if(bLen>=STREAK_TREND) return {side:'B', source:'PAIR'};

  // 2) Z-Skor (Mean-Revert adayı)
  const z = zScore();
  let meanCand=null;
  if(z >= Z_THR) meanCand = {side:'B', source:'MEAN'};      // Small aşırı → Big
  else if(z <= -Z_THR) meanCand = {side:'S', source:'MEAN'}; // Big aşırı → Small

  // 3) Mini Trend adayı
  let trendCand=null;
  if(sLen >= 1) trendCand = {side:'S', source:'TREND'};
  if(bLen >= 1) trendCand = {side:'B', source:'TREND'};

  // 4) Bandit (TREND vs MEAN) — ikisi de mevcutsa Thompson Sampling
  if(trendCand && meanCand){
    const drawBeta = (a,b)=> {
      const mean = a/(a+b);
      const jitter = (Math.random()*0.08-0.04); // ±0.04
      return Math.max(0, Math.min(1, mean + jitter));
    };
    const sT = drawBeta(beta.TREND.a, beta.TREND.b);
    const sM = drawBeta(beta.MEAN.a,  beta.MEAN.b);
    return (sT>=sM) ? trendCand : meanCand;
  }
  if(trendCand) return trendCand;
  if(meanCand)  return meanCand;

  // 5) Belirsiz → son akışa katıl
  if(histSig.length>=1){
    return {side:(histSig[histSig.length-1]==='S'?'S':'B'), source:'FALLBACK'};
  }
  return {side:'NONE', source:'NONE'};
}

function computeNextRecommendation(){
  if(warmActive){ recSide='NONE'; recSource='NONE'; return; }
  const rec = recommendCore();
  recSide   = rec.side;
  recSource = rec.source;
}

/* =============== Stake ilerleme =============== */
function boundedSoft(prev, inc){
  const u = dynamicUnit();
  const capU = prev + MAX_STEP_U*u;
  const capP = Math.round(prev * (lockedSide ? MAX_STEP_MULT_LOCK : MAX_STEP_MULT));
  return Math.min(prev + inc, capU, capP);
}
function currentDD(){ return Math.max(0, hwm - bank); }
function dynamicK(dd, u){
  if(dd <= 5*u) return 2;
  if(dd <= 15*u) return 3;
  return 4;
}
function kellyAdj(){
  const p = rollingWR();
  if(p===null || p<=0.5) return 0;
  return Math.min(0.25, 2*p - 1); // 0..0.25
}
function nextAfterLoss(prev){
  const u = dynamicUnit();
  const dd = currentDD();
  const K  = dynamicK(dd, u);
  const target = Math.max(u, Math.ceil(dd / Math.max(1,K)));
  const incNeed = Math.max(0, target - prev);
  const baseK = [1.00,1.15,1.25,1.35][Math.min(3, lossStreak)];
  const last = histSig[histSig.length-1] || 'S';
  const seriesLen = lastStreak(last);
  const seriesMult = (seriesLen >= ADAPT_SERIES_LEN) ? 0.6 : 1.0;
  let inc = Math.max(Math.ceil(baseK*u*seriesMult), incNeed, u);
  let ns  = boundedSoft(prev, inc);
  const kAdj = kellyAdj();
  ns = Math.round(ns * (1 + kAdj));
  if(lockedSide){
    const lockedAgainst = (lockedSide!==last);
    if(lockedAgainst){ ns = Math.max(u, Math.round(ns * 0.85)); }
  }
  return Math.max(u, ns);
}
function nextAfterWin(prev){
  const u = dynamicUnit();
  if(bank < hwm) return Math.max(u, Math.round(prev));
  let ns = Math.max(u, prev - 2*u);
  return ns;
}

/* =============== UI =============== */
function refreshKPI(){
  $('kBank').textContent = money(bank);
  $('kStake').textContent = (recSide==='NONE')?'—':String(stake);
  $('kUnit').textContent  = String(dynamicUnit());
  $('kHWM').textContent   = money(hwm);
  $('kWL').textContent    = `${wCount} / ${lCount}`;
  $('kPNL').textContent   = (bank-baseBank>=0?'+':'-')+money(Math.abs(bank-baseBank));
  $('kLStreak').textContent = String(lossStreak);
  const wr = rollingWR(); $('kWR').textContent = wr===null?'—':(Math.round(wr*100)+'%');
  $('kShadow').textContent = (shadowPNL>=0?'+':'-')+money(Math.abs(shadowPNL));
  const tag = (recSource==='PAUSE'?'Flip-Flop': (recSource==='PAIR'?'2xRule': (recSource==='LOCK'?'Kilit':recSource)));
  setRecoBadge(recSide, (recSide==='NONE'||!tag)?'':tag);
  $('recoStake').textContent = (recSide==='NONE')?'—':String(stake);
}
function addRow(src, recUsed, actual, usedStake, outcomeStr, pnl, shadowThis){
  nHands++;
  const tr = document.createElement('tr');
  const recTxt = recUsed==='NONE'?'—':(recUsed==='S'?'Small':'Big');
  const actTxt = actual==='S'?'Small':(actual==='B'?'Big':'Tie');
  tr.innerHTML = `
    <td>${nHands}</td>
    <td>${src}</td>
    <td>${recTxt}</td>
    <td>${actTxt}</td>
    <td>${recUsed==='NONE'?'—':usedStake}</td>
    <td>${outcomeStr}
      ${recUsed!=='NONE'?`<div class="sub" style="opacity:.8">Gölge: ${(shadowThis>=0?'+':'-')+money(Math.abs(shadowThis))} • Toplam: ${(shadowPNL>=0?'+':'-')+money(Math.abs(shadowPNL))}</div>`:''}
    </td>
    <td>${recUsed==='NONE'?'—':(pnl>=0?'+':'-')+money(Math.abs(pnl))}</td>
    <td>${money(bank)}</td>
  `;
  const tb = $('tbody'); if(tb.firstChild) tb.insertBefore(tr, tb.firstChild); else tb.appendChild(tr);
  $('live').textContent = `El ${nHands}: ${actTxt} geldi, ${outcomeStr}.`;
}

/* What-if toplam */
let shadowPNL = 0;

/* =============== Warm-up =============== */
function warmUpdateUI(){ $('wStat').textContent = `${warmSeq.length}/${MIN_WARMUP}`; }
function warmAdd(tag){
  if(!warmActive) return;
  if(warmSeq.length>=MIN_WARMUP) return;
  warmSeq.push(tag); warmUpdateUI();
  if(warmSeq.length===MIN_WARMUP){
    for(const t of warmSeq){
      histAll.push(t);
      if(t==='T'){ const last = histSig[histSig.length-1]; if(last) histSig.push(last); }
      else { histSig.push(t); }
    }
    warmSeq.length = 0; warmActive = false; $('warmPanel').style.display = 'none';
    // warm-up sonrası auto-unit ve stake başlangıcı
    unit  = autoUnitFromBank(baseBank);
    stake = unit;
    computeNextRecommendation();
    refreshKPI();
  }
}
function warmUndo(){ if(warmActive && warmSeq.length>0){ warmSeq.pop(); warmUpdateUI(); } }
function warmClear(){ if(warmActive){ warmSeq.length=0; warmUpdateUI(); } }

/* =============== Sonuç işlence =============== */
function onOutcome(tag){ // 'S'|'B'|'T'
  if(warmActive){ warmAdd(tag); return; }

  // decay uygula (öğrenmenin “güncelliğini” koru)
  decayBandit();

  const recUsed = recSide;
  const srcUsed = recSource;
  const usedStake = (recUsed==='NONE') ? 0 : stake;

  histAll.push(tag);
  if(tag==='T'){ const last = histSig[histSig.length-1]; if(last) histSig.push(last); }
  else { histSig.push(tag); }
  if(histSig.length>6000) histSig.shift();

  let pnl=0, out='Bekle', shadowThis=0;

  if(recUsed!=='NONE'){
    const isWin = (tag!=='T' && recUsed===tag);
    if(isWin){
      pnl = +usedStake; bank += pnl; out='KAZAN'; wCount++; lossStreak=0;
      if(srcUsed==='TREND') beta.TREND.a+=1; else if(srcUsed==='MEAN') beta.MEAN.a+=1;
      // kilit güven puanı
      if(srcUsed==='LOCK'){ SERIES_LOCK = Math.max(3, Math.round(SERIES_LOCK*0.98)); }
      stake = nextAfterWin(stake);
      histBetWR.push(1); if(histBetWR.length>W_WINRATE) histBetWR.shift();
      if(lockedSide){ lockLossCount = 0; }
    }else{
      pnl = -usedStake; bank += pnl; out='KAYIP'; lCount++; lossStreak++;
      if(srcUsed==='TREND') beta.TREND.b+=1; else if(srcUsed==='MEAN') beta.MEAN.b+=1;
      if(lockedSide && recUsed===lockedSide){
        lockLossCount++;
        const z = zScore();
        const zOpp = (lockedSide==='S' && z<=-Z_THR) || (lockedSide==='B' && z>=Z_THR);
        if(zOpp || lockLossCount>=HYST_LOSS){ lockedSide=null; oppSinceLockSig=0; lockLossCount=0; }
        // kilit kötü gidiyorsa eşiği ağırlaştıralım
        if(!lockedSide){ SERIES_LOCK = Math.min(6, Math.round(SERIES_LOCK*1.05)); }
      }
      stake = nextAfterLoss(stake);
      histBetWR.push(0); if(histBetWR.length>W_WINRATE) histBetWR.shift();
    }

    // What-if (karşı yön)
    const altSide = (recUsed==='S') ? 'B' : 'S';
    const altWin  = (tag!=='T' && altSide===tag);
    shadowThis = altWin ? +usedStake : -usedStake;
    shadowPNL += shadowThis;
  }

  const prevHWM = hwm;
  if(bank>hwm) hwm = bank;
  if(hwm>prevHWM){ stake = dynamicUnit(); }
  if(bank>=hwm && (bank-baseBank) >= CYCLE_TP_U*dynamicUnit()){ stake = dynamicUnit(); }
  maxStake = Math.max(maxStake, stake);

  addRow(srcUsed, recUsed, tag, usedStake, out, pnl, shadowThis);

  computeNextRecommendation();
  refreshKPI();
}

/* =============== Undo / Clear / Apply =============== */
function replay(){
  bank = baseBank; hwm = baseBank;
  unit = autoUnitFromBank(baseBank); stake = unit; maxStake=unit;
  lossStreak=0; nHands=0; wCount=0; lCount=0;
  histAll.length=0; histSig.length=0; histBetWR.length=0;
  lockedSide=null; oppSinceLockSig=0; lockLossCount=0; ffHold=false;
  recSide='NONE'; recSource='NONE'; shadowPNL=0;
  beta.TREND={a:1,b:1}; beta.MEAN={a:1,b:1}; Z_THR = 1.10; SERIES_LOCK = 4;
  $('tbody').innerHTML='';
  warmActive = true; warmSeq.length=0; $('warmPanel').style.display = 'block'; warmUpdateUI();
  refreshKPI();
}
function undo(){
  if(warmActive){ warmUndo(); return; }
  if(!histAll.length) return;
  const copy = histAll.slice(0,-1);
  // reset ve yeniden yürüt
  bank = baseBank; hwm = baseBank;
  unit = autoUnitFromBank(baseBank); stake=unit; maxStake=unit;
  lossStreak=0; nHands=0; wCount=0; lCount=0;
  histAll.length=0; histSig.length=0; histBetWR.length=0;
  lockedSide=null; oppSinceLockSig=0; lockLossCount=0; ffHold=false;
  recSide='NONE'; recSource='NONE'; shadowPNL=0;
  beta.TREND={a:1,b:1}; beta.MEAN={a:1,b:1}; Z_THR = 1.10; SERIES_LOCK = 4;
  $('tbody').innerHTML='';
  warmActive=false; $('warmPanel').style.display='none';

  for(const t of copy){ computeNextRecommendation(); onOutcome(t); }
  computeNextRecommendation(); refreshKPI();
}
function clearAll(){ if(confirm('Tüm kayıtları silmek istiyor musun?')){ replay(); } }
function apply(){
  const b = parseFloat($('bankIn').value);
  if(!Number.isFinite(b)||b<0){alert('Geçerli bank gir.');return}
  baseBank=b;
  replay(); // unit otomatik hesaplanır
}

/* =============== Toplu import =============== */
// Basit small/big/tie listelerini ve eski tablo formatını destekler
function parseLinesToTags(text){
  const tags = [];
  const lines = text.split(/\r?\n/);

  // 1) Basit satırlar: "small" | "big" | "tie" (veya s/b/t)
  let simpleHits = 0;
  for(const raw of lines){
    const t = raw.trim().toLowerCase();
    if(!t) continue;
    if(/\bsmall\b|^s$/.test(t)){ tags.push('S'); simpleHits++; continue; }
    if(/\bbig\b|^b$/.test(t)){ tags.push('B'); simpleHits++; continue; }
    if(/\btie\b|^t$/.test(t)){ tags.push('T'); simpleHits++; continue; }
  }
  if(simpleHits>0) return tags;

  // 2) Geriye dönük: "# FALLBACK Small Big 74 KAYIP" türü satırlar
  for(const raw of lines){
    const line = raw.trim();
    if(!line) continue;
    if(!/^\d+/.test(line)) continue;           // numarayla başlıyorsa al
    const parts = line.split(/\s+/);
    if(parts.length < 6) continue;
    const actual = parts[3];
    if(/small/i.test(actual)) tags.push('S');
    else if(/big/i.test(actual)) tags.push('B');
    else if(/tie/i.test(actual)) tags.push('T');
  }
  return tags;
}

// Veri-temelli başlangıç ayarı (trend'e hafif avantaj, erken kilit, mean-revert biraz geç)
function seedLearningFromDataset(){
  beta.TREND.a = 3; beta.TREND.b = 2;  // Trend'e ufak önyargı
  beta.MEAN.a  = 2; beta.MEAN.b  = 3;  // Mean'i biraz geriden başlat
  Z_THR = 1.18;                         // Tersine dönüşü biraz geciktir
  SERIES_LOCK = 3;                      // Kilidi bir tık erken kur
}

function importAndSim(text){
  const tags = parseLinesToTags(text);
  if(tags.length===0){ alert('Uygun satır bulunamadı.'); return; }

  // Veri tohumlama
  seedLearningFromDataset();

  // sıcak başlat: warm-up atla, otomatik u/stake
  warmActive=false; $('warmPanel').style.display='none';
  unit = autoUnitFromBank(baseBank); stake=unit;
  computeNextRecommendation(); refreshKPI();
  for(const t of tags){ onOutcome(t); }
  computeNextRecommendation(); refreshKPI();
}

/* =============== Bağlantılar =============== */
function guardTap(btn, pulse, cb){
  if(btn._lock) return; btn._lock=true;
  btn.classList.remove(pulse); void btn.offsetWidth; btn.classList.add(pulse);
  try{ cb(); } finally { setTimeout(()=>{ btn._lock=false; }, 220); }
}
$('btnSmall').addEventListener('click',()=>guardTap($('btnSmall'),'pulse-win', ()=>onOutcome('S')));
$('btnBig').addEventListener('click',  ()=>guardTap($('btnBig'),'pulse-loss', ()=>onOutcome('B')));
$('btnTie').addEventListener('click',  ()=>guardTap($('btnTie'),'pulse-tie',  ()=>onOutcome('T')));
$('btnUndo').addEventListener('click', ()=>undo());
$('btnClear').addEventListener('click',()=>clearAll());
$('apply').addEventListener('click',  ()=>apply());
$('reset').addEventListener('click',  ()=>{ $('bankIn').value=5000; apply(); });

/* Warm-up */
$('wSmall').addEventListener('click', ()=>guardTap($('wSmall'),'pulse-win', ()=>warmAdd('S')));
$('wBig').addEventListener('click',   ()=>guardTap($('wBig'),'pulse-loss',()=>warmAdd('B')));
$('wTie').addEventListener('click',   ()=>guardTap($('wTie'),'pulse-tie', ()=>warmAdd('T')));
$('wUndo').addEventListener('click',  ()=>warmUndo());
$('wClear').addEventListener('click', ()=>warmClear());

/* Import */
$('btnImport').addEventListener('click', ()=>importAndSim($('pasteArea').value));
$('btnImportClear').addEventListener('click', ()=>{$('pasteArea').value='';});

/* Kısayollar */
document.addEventListener('keydown',(e)=>{
  const t = e.target.tagName.toLowerCase();
  if(t==='input'||t==='select'||t==='textarea') return;
  if(e.key==='s'||e.key==='S'){ e.preventDefault(); $('btnSmall').click(); }
  if(e.key==='b'||e.key==='B'){ e.preventDefault(); $('btnBig').click(); }
  if(e.key==='t'||e.key==='T'){ e.preventDefault(); $('btnTie').click(); }
  if(e.key==='z'||e.key==='Z'){ e.preventDefault(); $('btnUndo').click(); }
  if(e.key==='1'){ e.preventDefault(); $('wSmall').click(); }
  if(e.key==='2'){ e.preventDefault(); $('wBig').click(); }
  if(e.key==='3'){ e.preventDefault(); $('wTie').click(); }
  if(e.key==='Backspace'){ if(warmActive){ e.preventDefault(); $('wUndo').click(); } }
});

/* Başlangıç */
$('warmPanel').style.display = 'block';
warmUpdateUI();
setRecoBadge('NONE');
$('kStake').textContent='—';
$('kUnit').textContent=String(unit);
$('kBank').textContent=money(baseBank);
})();
</script>
</body>
</html>
